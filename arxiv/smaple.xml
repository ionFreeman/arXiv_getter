<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <link href="http://arxiv.org/api/query?search_query%3Dcat%3Acs.LO%20AND%20all%3Acomputing%26id_list%3D%26start%3D0%26max_results%3D200" rel="self" type="application/atom+xml"/>
  <title type="html">ArXiv Query: search_query=cat:cs.LO AND all:computing&amp;id_list=&amp;start=0&amp;max_results=200</title>
  <id>http://arxiv.org/api/pggjcph1wYErIYvZuTn91E9UiMc</id>
  <updated>2020-04-04T00:00:00-04:00</updated>
  <opensearch:totalResults xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">10395</opensearch:totalResults>
  <opensearch:startIndex xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">0</opensearch:startIndex>
  <opensearch:itemsPerPage xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">200</opensearch:itemsPerPage>
      <entry>
    <id>http://arxiv.org/abs/1501.05260v3</id>
    <updated>2018-11-28T16:05:33Z</updated>
    <published>2015-01-17T04:55:39Z</published>
    <title>An Algebra of Reversible Quantum Computing</title>
    <summary>  We extend the algebra of reversible computation to support quantum computing.
Since the algebra is based on true concurrency, it is reversible for quantum
computing and it has a sound and complete theory.
</summary>
    <author>
      <name>Yong Wang</name>
    </author>
    <link href="http://arxiv.org/abs/1501.05260v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1501.05260v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.02817v1</id>
    <updated>2015-04-10T23:58:00Z</updated>
    <published>2015-04-10T23:58:00Z</published>
    <title>Towards A Theory Of Quantum Computability</title>
    <summary>  We propose a definition of quantum computable functions as mappings between
superpositions of natural numbers to probability distributions of natural
numbers. Each function is obtained as a limit of an infinite computation of a
quantum Turing machine. The class of quantum computable functions is
recursively enumerable, thus opening the door to a quantum computability theory
which may follow some of the classical developments.
</summary>
    <author>
      <name>Stefano Guerrini</name>
    </author>
    <author>
      <name>Simone Martini</name>
    </author>
    <author>
      <name>Andrea Masini</name>
    </author>
    <link href="http://arxiv.org/abs/1504.02817v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.02817v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1006.0395v1</id>
    <updated>2010-06-02T14:30:13Z</updated>
    <published>2010-06-02T14:30:13Z</published>
    <title>Computation with Advice</title>
    <summary>  Computation with advice is suggested as generalization of both computation
with discrete advice and Type-2 Nondeterminism. Several embodiments of the
generic concept are discussed, and the close connection to Weihrauch
reducibility is pointed out. As a novel concept, computability with random
advice is studied; which corresponds to correct solutions being guessable with
positive probability. In the framework of computation with advice, it is
possible to define computational complexity for certain concepts of
hypercomputation. Finally, some examples are given which illuminate the
interplay of uniform and non-uniform techniques in order to investigate both
computability with advice and the Weihrauch lattice.
</summary>
    <author>
      <name>Vasco Brattka</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cape Town</arxiv:affiliation>
    </author>
    <author>
      <name>Arno Pauly</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cambridge</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.24.9</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.24.9" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 24, 2010, pp. 41-55</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1006.0395v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1006.0395v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1602.08004v2</id>
    <updated>2017-03-17T14:12:23Z</updated>
    <published>2016-02-25T17:25:57Z</published>
    <title>A topological view on algebraic computation models</title>
    <summary>  We investigate the topological aspects of some algebraic computation models,
in particular the BSS-model. Our results can be seen as bounds on how different
BSS-computability and computability in the sense of computable analysis can be.
The framework for this is Weihrauch reducibility. As a consequence of our
characterizations, we establish that the solvability complexity index is
(mostly) independent of the computational model, and that there thus is common
ground in the study of non-computability between the BSS and TTE setting.
</summary>
    <author>
      <name>Eike Neumann</name>
    </author>
    <author>
      <name>Arno Pauly</name>
    </author>
    <link href="http://arxiv.org/abs/1602.08004v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1602.08004v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1712.09404v1</id>
    <updated>2017-12-09T13:07:27Z</updated>
    <published>2017-12-09T13:07:27Z</published>
    <title>The Algebraic View of Computation</title>
    <summary>  We argue that computation is an abstract algebraic concept, and a computer is
a result of a morphism (a structure preserving map) from a finite universal
semigroup.
</summary>
    <author>
      <name>Attila Egri-Nagy</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.3390/philosophies3020015</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.3390/philosophies3020015" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">13 pages, final version will be published elsewhere</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Philosophies 2018, 3(2), 15
  https://doi.org/10.3390/philosophies3020015</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1712.09404v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1712.09404v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.13112v2</id>
    <updated>2020-02-16T15:20:13Z</updated>
    <published>2019-04-30T09:07:37Z</published>
    <title>On the incomputability of computable dimension</title>
    <summary>  Using an iterative tree construction we show that for simple computable
subsets of the Cantor space Hausdorff, constructive and computable dimensions
amight be incomputable.
</summary>
    <author>
      <name>Ludwig Staiger</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1904.13112v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.13112v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68Q30, 03D32" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2003.02087v1</id>
    <updated>2020-03-04T14:01:39Z</updated>
    <published>2020-03-04T14:01:39Z</published>
    <title>An effective version of definability in metric model theory</title>
    <summary>  In this paper, a computably definable predicate is defined and characterized.
Then, it is proved that every separable infinite-dimensional Hilbert structure
in an effectively presented language is computable. Moreover, every definable
predicate in these structures is computable.
</summary>
    <author>
      <name>Nazanin Roshandel Tavana</name>
    </author>
    <link href="http://arxiv.org/abs/2003.02087v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2003.02087v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1604.00258v3</id>
    <updated>2018-12-04T17:52:08Z</updated>
    <published>2016-04-01T14:24:02Z</published>
    <title>Computable dyadic subbases and $mathbf{T}^ω$-representations of
  compact sets</title>
    <summary>  We explore representing the compact subsets of a given represented space by
infinite sequences over Plotkin's $mathbb{T}$. We show that computably compact
computable metric spaces admit representations of their compact subsets in such
a way that compact sets are essentially underspecified points. We can even
ensure that a name of an $n$-element compact set contains $n$ occurrences of
$bot$. We undergo this study effectively and show that such a
$mathbb{T}^omega$-representation is effectively obtained from structures of
computably compact computable metric spaces. As an application, we prove some
statements about the Weihrauch degree of closed choice for finite subsets of
computably compact computable metric spaces.
  Along the way, we introduce the notion of a computable dyadic subbase, and
prove that every computably compact computable metric space admits a proper
computable dyadic subbase.
</summary>
    <author>
      <name>Arno Pauly</name>
    </author>
    <author>
      <name>Hideki Tsuiki</name>
    </author>
    <link href="http://arxiv.org/abs/1604.00258v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1604.00258v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03F60, 54F05, 03D30" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.08699v1</id>
    <updated>2016-06-26T19:38:10Z</updated>
    <published>2016-06-26T19:38:10Z</published>
    <title>How to Compute Halting</title>
    <summary>  A consistently specified halting function may be computed.
</summary>
    <author>
      <name>Eric C. R. Hehner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1606.08699v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.08699v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1702.05073v3</id>
    <updated>2018-06-26T01:19:41Z</updated>
    <published>2017-02-16T18:27:19Z</published>
    <title>A Game-Semantic Model of Computation</title>
    <summary>  The present paper introduces a novel notion of `(effective) computability',
called viability, of strategies in game semantics in an intrinsic (i.e.,
without recourse to the standard Church-Turing computability), non-inductive
and non-axiomatic manner, and shows, as a main technical achievement, that
viable strategies are Turing complete. Consequently, we have given a
mathematical foundation of computation in the same sense as Turing machines but
beyond computation on natural numbers, e.g., higher-order computation, in a
more abstract fashion. As immediate corollaries, some of the well-known
theorems in computability theory such as the smn-theorem and the first
recursion theorem are generalized. Notably, our game-semantic framework
distinguishes `high-level' computational processes that operate directly on
mathematical objects such as natural numbers (not on their symbolic
representations) and their `symbolic implementations' that define their
`computability', which sheds new light on the very concept of computation. This
work is intended to be a stepping stone towards a new mathematical foundation
of computation, intuitionistic logic and constructive mathematics.
</summary>
    <author>
      <name>Norihiro Yamada</name>
    </author>
    <link href="http://arxiv.org/abs/1702.05073v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1702.05073v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1802.03292v1</id>
    <updated>2018-02-07T22:21:43Z</updated>
    <published>2018-02-07T22:21:43Z</published>
    <title>Mathematical Logic in Computer Science</title>
    <summary>  The article retraces major events and milestones in the mutual influences
between mathematical logic and computer science since the 1950s.
</summary>
    <author>
      <name>Assaf Kfoury</name>
    </author>
    <link href="http://arxiv.org/abs/1802.03292v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1802.03292v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03B70, 68Q99" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1; F.4.m; K.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1004.4998v1</id>
    <updated>2010-04-28T11:04:47Z</updated>
    <published>2010-04-28T11:04:47Z</published>
    <title>Computing in Coq with Infinite Algebraic Data Structures</title>
    <summary>  Computational content encoded into constructive type theory proofs can be
used to make computing experiments over concrete data structures. In this
paper, we explore this possibility when working in Coq with chain complexes of
infinite type (that is to say, generated by infinite sets) as a part of the
formalization of a hierarchy of homological algebra structures.
</summary>
    <author>
      <name>César Domínguez</name>
    </author>
    <author>
      <name>Julio Rubio</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Conferences on Intelligent Computer Mathematics 2010</arxiv:comment>
    <link href="http://arxiv.org/abs/1004.4998v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1004.4998v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1303.2507v1</id>
    <updated>2013-03-11T13:07:42Z</updated>
    <published>2013-03-11T13:07:42Z</published>
    <title>What Makes a Computation Unconventional?</title>
    <summary>  A coherent mathematical overview of computation and its generalisations is
described. This conceptual framework is sufficient to comfortably host a wide
range of contemporary thinking on embodied computation and its models.
</summary>
    <author>
      <name>S. Barry Cooper</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Based on an invited lecture for the 'Symposium on
  Natural/Unconventional Computing and Its Philosophical Significance' at the
  AISB/IACAP World Congress 2012, University of Birmingham, July 2-6, 2012</arxiv:comment>
    <link href="http://arxiv.org/abs/1303.2507v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1303.2507v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.08918v2</id>
    <updated>2017-04-27T11:49:16Z</updated>
    <published>2016-08-31T16:04:37Z</published>
    <title>Subcomputable Schnorr Randomness</title>
    <summary>  The notion of Schnorr randomness refers to computable reals or computable
functions. We propose a version of Schnorr randomness for subcomputable classes
and characterize it in different ways: by Martin L\\"of tests, martingales or
measure computable machines.
</summary>
    <author>
      <name>Claude Sureson</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.23638/LMCS-13(2:2)2017</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.23638/LMCS-13(2:2)2017" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 13, Issue 2 (April 28,
  2017) lmcs:3290</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1608.08918v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.08918v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03D25, 68Q15" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1106.2272v1</id>
    <updated>2011-06-12T02:20:53Z</updated>
    <published>2011-06-12T02:20:53Z</published>
    <title>Soundness and completeness of the cirquent calculus system CL6 for
  computability logic</title>
    <summary>  Computability logic is a formal theory of computability. The earlier article
"Introduction to cirquent calculus and abstract resource semantics" by
Japaridze proved soundness and completeness for the basic fragment CL5 of
computability logic. The present article extends that result to the more
expressive cirquent calculus system CL6, which is a conservative extension of
both CL5 and classical propositional logic.
</summary>
    <author>
      <name>Wenyan Xu</name>
    </author>
    <author>
      <name>Sanyang Liu</name>
    </author>
    <link href="http://arxiv.org/abs/1106.2272v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1106.2272v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.03344v3</id>
    <updated>2018-11-28T17:41:27Z</updated>
    <published>2015-07-13T07:47:41Z</published>
    <title>Entanglement in Reversible Quantum Computing</title>
    <summary>  Similarly to the modelling of entanglement in the algebra of quantum
computing, we also model entanglement as a synchronization among an event and
its shadows in reversible quantum computing. We give the semantics and axioms
of shadow constant for reversible quantum computing.
</summary>
    <author>
      <name>Yong Wang</name>
    </author>
    <link href="http://arxiv.org/abs/1507.03344v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.03344v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1811.04566v2</id>
    <updated>2019-03-23T10:51:41Z</updated>
    <published>2018-11-12T05:49:09Z</published>
    <title>An Algorithm for Computing Prime Implicates in Modal Logic Using
  Resolution</title>
    <summary>  In this paper we have proposed an algorithm for computing prime implicates of
a modal formula in $mathbf{K}$ using resolution method suggested in
cite{Enjalbert}. The algorithm suggested in this paper takes polynomial times
exponential time ,i.e, $O(n^{2k}times 2^{n})$ to compute prime implicates
whereas Binevenu's algorithm cite{Bienvenu} takes doubly exponential time to
compute prime implicates. We have also proved its correctness.
</summary>
    <author>
      <name>Manoj K. Raut</name>
    </author>
    <link href="http://arxiv.org/abs/1811.04566v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1811.04566v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1906.05340v1</id>
    <updated>2019-06-11T09:47:19Z</updated>
    <published>2019-06-11T09:47:19Z</published>
    <title>The Halting Paradox</title>
    <summary>  The halting problem is considered to be an essential part of the theoretical
background to computing. That halting is not in general computable has
supposedly been proved in many text books and taught on many computer science
courses, in order to illustrate the limits of computation. However, Eric Hehner
has a dissenting view, in which the specification of the halting problem is
called into question.
</summary>
    <author>
      <name>Bill Stoddart</name>
    </author>
    <link href="http://arxiv.org/abs/1906.05340v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1906.05340v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1906.12220v2</id>
    <updated>2019-10-29T05:20:31Z</updated>
    <published>2019-06-28T13:48:32Z</published>
    <title>Computing Haar Measures</title>
    <summary>  According to Haar's Theorem, every compact group $G$ admits a unique
(regular, right and) left-invariant Borel probability measure $mu_G$. Let the
Haar integral (of $G$) denote the functional $int_G:mathcal{C}(G)\
i fmapsto
int f\\,dmu_G$ integrating any continuous function $f:Gtomathbb{R}$ with
respect to $mu_G$. This generalizes, and recovers for the additive group
$G=[0;1)mod 1$, the usual Riemann integral: computable (cmp. Weihrauch 2000,
Theorem 6.4.1), and of computational cost characterizing complexity class
#P$_1$ (cmp. Ko 1991, Theorem 5.32). We establish that in fact every computably
compact computable metric group renders the Haar integral computable: once
asserting computability using an elegant synthetic argument, exploiting
uniqueness in a computably compact space of probability measures; and once
presenting and analyzing an explicit, imperative algorithm based on 'maximum
packings' with rigorous error bounds and guaranteed convergence. Regarding
computational complexity, for the groups $mathcal{SO}(3)$ and
$mathcal{SU}(2)$ we reduce the Haar integral to and from Euclidean/Riemann
integration. In particular both also characterize #P$_1$. Implementation and
empirical evaluation using the iRRAM C++ library for exact real computation
confirms the (thus necessary) exponential runtime.
</summary>
    <author>
      <name>Arno Pauly</name>
    </author>
    <author>
      <name>Dongseong Seon</name>
    </author>
    <author>
      <name>Martin Ziegler</name>
    </author>
    <link href="http://arxiv.org/abs/1906.12220v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1906.12220v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="65J05, 03D78, 68Q65" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.2.1; F.4.1; G.1.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0806.3209v1</id>
    <updated>2008-06-19T18:09:01Z</updated>
    <published>2008-06-19T18:09:01Z</published>
    <title>A Computer Verified Theory of Compact Sets</title>
    <summary>  Compact sets in constructive mathematics capture our intuition of what
computable subsets of the plane (or any other complete metric space) ought to
be. A good representation of compact sets provides an efficient means of
creating and displaying images with a computer. In this paper, I build upon
existing work about complete metric spaces to define compact sets as the
completion of the space of finite sets under the Hausdorff metric. This
definition allowed me to quickly develop a computer verified theory of compact
sets. I applied this theory to compute provably correct plots of uniformly
continuous functions.
</summary>
    <author>
      <name>Russell O'Connor</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This paper is to be part of the proceedings of the Symbolic
  Computation in Software Science Austrian-Japanese Workshop (SCSS 2008)</arxiv:comment>
    <link href="http://arxiv.org/abs/0806.3209v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0806.3209v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.02500v1</id>
    <updated>2016-10-08T08:48:09Z</updated>
    <published>2016-10-08T08:48:09Z</published>
    <title>Probabilistic Process Algebra to Unifying Quantum and Classical
  Computing in Closed Systems</title>
    <summary>  We have unified quantum and classical computing in open quantum systems
called qACP which is a quantum generalization of process algebra ACP. But, an
axiomatization for quantum and classical processes with an assumption of closed
quantum systems is still missing. For closed quantum systems, unitary operator,
quantum measurement and quantum entanglement are three basic components for
quantum computing. This leads to probability unavoidable. Along the solution of
qACP to unify quantum and classical computing in open quantum systems, we unify
quantum and classical computing with an assumption of closed systems under the
framework of ACP-like probabilistic process algebra. This unification make it
can be used widely in verification for quantum and classical computing mixed
systems, such as most quantum communication protocols.
</summary>
    <author>
      <name>Yong Wang</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">64 pages, 3 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1610.02500v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.02500v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0207074v1</id>
    <updated>2002-07-21T06:19:23Z</updated>
    <published>2002-07-21T06:19:23Z</published>
    <title>Paraconsistency of Interactive Computation</title>
    <summary>  The goal of computational logic is to allow us to model computation as well
as to reason about it. We argue that a computational logic must be able to
model interactive computation. We show that first-order logic cannot model
interactive computation due to the incompleteness of interaction. We show that
interactive computation is necessarily paraconsistent, able to model both a
fact and its negation, due to the role of the world (environment) in
determining the course of the computation. We conclude that paraconsistency is
a necessary property for a logic that can model interactive computation.
</summary>
    <author>
      <name>Dina Goldin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">U. of Connecticut</arxiv:affiliation>
    </author>
    <author>
      <name>Peter Wegner</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Brown U.</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, no figures. Originally published in proc. PCL 2002, a FLoC
  workshop; eds. Hendrik Decker, Dina Goldin, Jorgen Villadsen, Toshiharu
  Waragai (http://floc02.diku.dk/PCL/)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0207074v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0207074v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1; F.1.2; I.2.0; I.2.11" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0305007v1</id>
    <updated>2003-05-13T08:27:45Z</updated>
    <published>2003-05-13T08:27:45Z</published>
    <title>Computing only minimal answers in disjunctive deductive databases</title>
    <summary>  A method is presented for computing minimal answers in disjunctive deductive
databases under the disjunctive stable model semantics. Such answers are
constructed by repeatedly extending partial answers. Our method is complete (in
that every minimal answer can be computed) and does not admit redundancy (in
the sense that every partial answer generated can be extended to a minimal
answer), whence no non-minimal answer is generated. For stratified databases,
the method does not (necessarily) require the computation of models of the
database in their entirety. Compilation is proposed as a tool by which problems
relating to computational efficiency and the non-existence of disjunctive
stable models can be overcome. The extension of our method to other semantics
is also considered.
</summary>
    <author>
      <name>C. A. Johnson</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">48 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0305007v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0305007v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0708.0200v2</id>
    <updated>2007-11-05T09:48:05Z</updated>
    <published>2007-08-01T17:22:48Z</published>
    <title>A Note on Shortest Developments</title>
    <summary>  De Vrijer has presented a proof of the finite developments theorem which, in
addition to showing that all developments are finite, gives an effective
reduction strategy computing longest developments as well as a simple formula
computing their length.
  We show that by applying a rather simple and intuitive principle of duality
to de Vrijer's approach one arrives at a proof that some developments are
finite which in addition yields an effective reduction strategy computing
shortest developments as well as a simple formula computing their length. The
duality fails for general beta-reduction.
  Our results simplify previous work by Khasidashvili.
</summary>
    <author>
      <name>Morten Heine Sørensen</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-3(4:2)2007</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-3(4:2)2007" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 3, Issue 4 (November
  5, 2007) lmcs:838</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0708.0200v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0708.0200v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.0717v2</id>
    <updated>2013-09-16T15:13:26Z</updated>
    <published>2013-09-03T15:08:39Z</published>
    <title>A Polynomial Translation of pi-calculus FCPs to Safe Petri Nets</title>
    <summary>  We develop a polynomial translation from finite control pi-calculus processes
to safe low-level Petri nets. To our knowledge, this is the first such
translation. It is natural in that there is a close correspondence between the
control flows, enjoys a bisimulation result, and is suitable for practical
model checking.
</summary>
    <author>
      <name>Victor Khomenko</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">School of Computing Science, Newcastle University</arxiv:affiliation>
    </author>
    <author>
      <name>Roland Meyer</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, University of Kaiserslautern</arxiv:affiliation>
    </author>
    <author>
      <name>Reiner Hüchting</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, University of Kaiserslautern</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-9(3:18)2013</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-9(3:18)2013" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in special issue on best papers of CONCUR'12 of Logical
  Methods in Computer Science</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 9, Issue 3 (September
  17, 2013) lmcs:932</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.0717v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.0717v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1510.04469v3</id>
    <updated>2017-04-13T10:16:56Z</updated>
    <published>2015-10-15T11:03:53Z</published>
    <title>A Formal System: Rigorous Constructions of Computer Models</title>
    <summary>  This book explores an alternative to the current dominant paradigm where a
discrete computer model is constructed as an attempt to approximate some
continuum theory. We focus on a class of discrete computer models that are
based on simple deterministic rules and finite state arithmetic. Such models
are highly compatible with the operational parameters of the real world
computer on which they are executed and hence their validation can be
associated with the allowable computations on the machine. A simple formal
system based on a language of functional programs is employed as a tool of
analysis.
</summary>
    <author>
      <name>Garry Pantelis</name>
    </author>
    <link href="http://arxiv.org/abs/1510.04469v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1510.04469v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03B35 (Primary), 00A71, 03B15 (Secondary)" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.6466v1</id>
    <updated>2014-09-23T10:00:04Z</updated>
    <published>2014-09-23T10:00:04Z</published>
    <title>Quantitative Computation Tree Logic Model Checking Based on Generalized
  Possibility Measures</title>
    <summary>  We study generalized possibilistic computation tree logic model checking in
this paper, which is an extension of possibilistic computation logic model
checking introduced by Y.Li, Y.Li and Z.Ma (2014). The system is modeled by
generalized possibilistic Kripke structures (GPKS, in short), and the verifying
property is specified by a generalized possibilistic computation tree logic
(GPoCTL, in short) formula. Based on generalized possibility measures and
generalized necessity measures, the method of generalized possibilistic
computation tree logic model checking is discussed, and the corresponding
algorithm and its complexity are shown in detail. Furthermore, the comparison
between PoCTL introduced in (2013) and GPoCTL is given. Finally, a thermostat
example is given to illustrate the GPoCTL model-checking method.
</summary>
    <author>
      <name>Yongming Li</name>
    </author>
    <author>
      <name>Zhanyou Ma</name>
    </author>
    <link href="http://arxiv.org/abs/1409.6466v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.6466v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.13220v1</id>
    <updated>2019-10-29T12:11:45Z</updated>
    <published>2019-10-29T12:11:45Z</published>
    <title>Effective Wadge Hierarchy in Computable Quasi-Polish Spaces</title>
    <summary>  We define and study an effective version of the Wadge hierarchy in computable
quasi-Polish spaces which include most spaces of interest for computable
analysis. Along with hierarchies of sets we study hierarchies of k-partitions
which are interesting on their own. We show that levels of such hierarchies are
preserved by the computable effectively open surjections, that if the effective
Hausdorff-Kuratowski theorem holds in the Baire space then it holds in every
computable quasi-Polish space, and we extend the effective Hausdorff theorem to
k-partitions.
</summary>
    <author>
      <name>Victor Selivanov</name>
    </author>
    <link href="http://arxiv.org/abs/1910.13220v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.13220v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03D55, 03D78" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.2.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1207.1188v1</id>
    <updated>2012-07-05T08:28:41Z</updated>
    <published>2012-07-05T08:28:41Z</published>
    <title>On the toggling-branching recurrence of Computability Logic</title>
    <summary>  We introduce a new, substantially simplified version of the
toggling-branching recurrence operation of Computability Logic, prove its
equivalence to Japaridze's old, "canonical" version, and also prove that both
versions preserve the static property of their arguments.
</summary>
    <author>
      <name>Meixia Qu</name>
    </author>
    <author>
      <name>Junfeng Luan</name>
    </author>
    <author>
      <name>Daming Zhu</name>
    </author>
    <link href="http://arxiv.org/abs/1207.1188v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1207.1188v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1612.04513v1</id>
    <updated>2016-12-14T07:21:04Z</updated>
    <published>2016-12-14T07:21:04Z</published>
    <title>A survey of computability logic</title>
    <summary>  This article presents a survey of computability logic: its philosophy and
motivations, main concepts and most significant results obtained so far. A
continuously updated online version of this article is maintained at
http://www.csc.villanova.edu/~japaridz/CL/ .
</summary>
    <author>
      <name>Giorgi Japaridze</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: text overlap with arXiv:cs/0507045</arxiv:comment>
    <link href="http://arxiv.org/abs/1612.04513v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1612.04513v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03F50, 03D75, 03D15, 68Q10, 68T27, 68T30" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.1.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0011037v2</id>
    <updated>2001-09-14T09:27:17Z</updated>
    <published>2000-11-23T10:09:06Z</published>
    <title>A syntactical analysis of non-size-increasing polynomial time
  computation</title>
    <summary>  A syntactical proof is given that all functions definable in a certain affine
linear typed lambda-calculus with iteration in all types are polynomial time
computable. The proof provides explicit polynomial bounds that can easily be
calculated.
</summary>
    <author>
      <name>Klaus Aehlig</name>
    </author>
    <author>
      <name>Helmut Schwichtenberg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">20 pages (latex), revised submission (expanded proofs, extended
  references, new section on tree iteration)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">ACM Transactions on Computational Logic 3(3), 383-401 (2002)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0011037v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0011037v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1; F.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0403041v1</id>
    <updated>2004-03-29T15:20:32Z</updated>
    <published>2004-03-29T15:20:32Z</published>
    <title>A Theory of Computation Based on Quantum Logic (I)</title>
    <summary>  The (meta)logic underlying classical theory of computation is Boolean
(two-valued) logic. Quantum logic was proposed by Birkhoff and von Neumann as a
logic of quantum mechanics more than sixty years ago. The major difference
between Boolean logic and quantum logic is that the latter does not enjoy
distributivity in general. The rapid development of quantum computation in
recent years stimulates us to establish a theory of computation based on
quantum logic. The present paper is the first step toward such a new theory and
it focuses on the simplest models of computation, namely finite automata. It is
found that the universal validity of many properties of automata depend heavily
upon the distributivity of the underlying logic. This indicates that these
properties does not universally hold in the realm of quantum logic. On the
other hand, we show that a local validity of them can be recovered by imposing
a certain commutativity to the (atomic) statements about the automata under
consideration. This reveals an essential difference between the classical
theory of computation and the computation theory based on quantum logic.
</summary>
    <author>
      <name>Mingsheng Ying</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theoretical Computer Science 344(2-3): 134-207 (2005)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0403041v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0403041v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.1.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1105.4060v1</id>
    <updated>2011-05-20T11:18:13Z</updated>
    <published>2011-05-20T11:18:13Z</published>
    <title>Logical Modelling of Physarum Polycephalum</title>
    <summary>  We propose a novel model of unconventional computing where a structural part
of computation is presented by dynamics of plasmodium of Physarum polycephalum,
a large single cell. We sketch a new logical approach combining conventional
logic with process calculus to demonstrate how to employ formal methods in
design of unconventional computing media presented by Physarum polycephalum.
</summary>
    <author>
      <name>Andrew Schumann</name>
    </author>
    <author>
      <name>Andrew Adamatzky</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Analele Universitatii de Vest, Timisoara, Seria Matematica -
  Informatica XLVIII, 3, (2010), 175-190</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1105.4060v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1105.4060v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1402.2102v1</id>
    <updated>2014-02-10T11:04:39Z</updated>
    <published>2014-02-10T11:04:39Z</published>
    <title>PTIME Computation of Transitive Closures of Octagonal Relations</title>
    <summary>  Computing transitive closures of integer relations is the key to finding
precise invariants of integer programs. In this paper, we study difference
bounds and octagonal relations and prove that their transitive closure is a
PTIME-computable formula in the existential fragment of Presburger arithmetic.
This result marks a significant complexity improvement, as the known algorithms
have EXPTIME worst case complexity.
</summary>
    <author>
      <name>Filip Konecny</name>
    </author>
    <link href="http://arxiv.org/abs/1402.2102v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1402.2102v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.3378v2</id>
    <updated>2014-06-25T19:45:05Z</updated>
    <published>2014-06-12T21:33:48Z</published>
    <title>Probabilistic Recursion Theory and Implicit Computational Complexity
  (Long Version)</title>
    <summary>  We show that probabilistic computable functions, i.e., those functions
outputting distributions and computed by probabilistic Turing machines, can be
characterized by a natural generalization of Church and Kleene's partial
recursive functions. The obtained algebra, following Leivant, can be restricted
so as to capture the notion of polytime sampleable distributions, a key concept
in average-case complexity and cryptography.
</summary>
    <author>
      <name>Ugo Dal Lago</name>
    </author>
    <author>
      <name>Sara Zuppiroli</name>
    </author>
    <link href="http://arxiv.org/abs/1406.3378v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.3378v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1811.01070v2</id>
    <updated>2018-11-27T15:40:16Z</updated>
    <published>2018-11-02T20:07:55Z</published>
    <title>Truly Concurrent Process Algebra to Unifying Quantum and Classical
  Computing</title>
    <summary>  Based on our previous work on truly concurrent process algebra, we use it to
unify quantum and classical computing for open and closed quantum systems. This
resulted algebra can be used to verify the behaviors of quantum and classical
computing mixed systems, with a flavor of true concurrency.
</summary>
    <author>
      <name>Yong Wang</name>
    </author>
    <link href="http://arxiv.org/abs/1811.01070v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1811.01070v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.02297v3</id>
    <updated>2015-08-11T16:52:26Z</updated>
    <published>2015-07-08T20:17:50Z</published>
    <title>Equivalence Checking and Simulation By Computing Range Reduction</title>
    <summary>  We introduce new methods of equivalence checking and simulation based on
Computing Range Reduction (CRR). Given a combinational circuit $N$, the CRR
problem is to compute the set of outputs that disappear from the range of $N$
if a set of inputs of $N$ is excluded from consideration. Importantly, in many
cases, range reduction can be efficiently found even if computing the entire
range of $N$ is infeasible.
  Solving equivalence checking by CRR facilitates generation of proofs of
equivalence that mimic a "cut propagation" approach. A limited version of such
an approach has been successfully used by commercial tools. Functional
verification of a circuit $N$ by simulation can be viewed as a way to reduce
the complexity of computing the range of $N$. Instead of finding the entire
range of $N$ and checking if it contains a bad output, such a range is computed
only for one input. Simulation by CRR offers an alternative way of coping with
the complexity of range computation. The idea is to exclude a subset of inputs
of $N$ and compute the range reduction caused by such an exclusion. If the set
of disappeared outputs contains a bad one, then $N$ is buggy.
</summary>
    <author>
      <name>Eugene Goldberg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">The difference of this version from the previous one (i.e. version
  number 2) is twofold. First, I improved the readability of the paper. Second,
  I removed the claim that equivalence checking by computing range reduction is
  noise-insensitive. The final result is indeed noise-insensitive but the
  presence of noise may drastically slow down an algorithm computing this
  result</arxiv:comment>
    <link href="http://arxiv.org/abs/1507.02297v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.02297v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0109001v1</id>
    <updated>2001-09-02T18:52:51Z</updated>
    <published>2001-09-02T18:52:51Z</published>
    <title>Abstract Computability, Algebraic Specification and Initiality</title>
    <summary>  computable functions are defined by abstract finite deterministic algorithms
on many-sorted algebras. We show that there exist finite universal algebraic
specifications that specify uniquely (up to isomorphism) (i) all abstract
computable functions on any many-sorted algebra; and (ii) all functions
effectively approximable by abstract computable functions on any metric
algebra.
  We show that there exist universal algebraic specifications for all the
classically computable functions on the set R of real numbers. The algebraic
specifications used are mainly bounded universal equations and conditional
equations. We investigate the initial algebra semantics of these
specifications, and derive situations where algebraic specifications define
precisely the computable functions.
</summary>
    <author>
      <name>J. V. Tucker</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Wales, Swansea</arxiv:affiliation>
    </author>
    <author>
      <name>J. I. Zucker</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">McMaster University, Hamilton, Canada</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in ACM Transactions on Computational Logic (57 pages;
  AMSTeX)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0109001v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0109001v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1;F.3.1;F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1011.1335v1</id>
    <updated>2010-11-05T07:54:47Z</updated>
    <published>2010-11-05T07:54:47Z</published>
    <title>A short proof that adding some permutation rules to $β$ preserves
  $SN$</title>
    <summary>  I show that, if a term is $SN$ for $beta$, it remains $SN$ when some
permutation rules are added.
</summary>
    <author>
      <name>Rene David</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.tcs.2010.10.048</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.tcs.2010.10.048" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Theoretical Computer Science, 2010</arxiv:comment>
    <link href="http://arxiv.org/abs/1011.1335v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1011.1335v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1509.06429v1</id>
    <updated>2015-09-21T23:46:26Z</updated>
    <published>2015-09-21T23:46:26Z</published>
    <title>On Computational Paths and the Fundamental Groupoid of a Type</title>
    <summary>  The main objective of this work is to study mathematical properties of
computational paths. Originally proposed by de Queiroz \\&amp; Gabbay (1994) as
`sequences of rewrites', computational paths can be seen as the grounds on
which the propositional equality between two computational objects stand. Using
computational paths and categorical semantics, we take any type $A$ of type
theory and construct a groupoid for this type. We call this groupoid the
fundamental groupoid of a type $A$, since it is similar to the one obtained
using the homotopical interpretation of the identity type. The main difference
is that instead of being just a semantical interpretation, computational paths
are entities of the syntax of type theory. We also expand our results, using
computational paths to construct fundamental groupoids of higher levels.
</summary>
    <author>
      <name>Arthur F. Ramos</name>
    </author>
    <author>
      <name>Ruy J. G. B. de Queiroz</name>
    </author>
    <author>
      <name>Anjolina de Oliveira</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, submitted to LFCS</arxiv:comment>
    <link href="http://arxiv.org/abs/1509.06429v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1509.06429v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1403.7353v1</id>
    <updated>2014-03-28T12:10:05Z</updated>
    <published>2014-03-28T12:10:05Z</published>
    <title>Exposition: Synthesis via Functional Interpretation</title>
    <summary>  The aim of this short paper is to give a practical introduction to functional
interpretation of proofs for computer scientists interested in synthesis.
</summary>
    <author>
      <name>Daniel Weller</name>
    </author>
    <link href="http://arxiv.org/abs/1403.7353v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1403.7353v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1506.02721v2</id>
    <updated>2016-09-08T18:24:15Z</updated>
    <published>2015-06-08T23:11:51Z</published>
    <title>On the Groupoid Model of Computational Paths</title>
    <summary>  The main objective of this work is to study mathematical properties of
computational paths. Originally proposed by de Queiroz \\&amp; Gabbay (1994) as
`sequences or rewrites', computational paths are taken to be terms of the
identity type of Martin L\\"of's Intensional Type Theory, since these paths can
be seen as the grounds on which the propositional equality between two
computational objects stand. From this perspective, this work aims to show that
one of the properties of the identity type is present on computational paths.
We are referring to the fact that that the identity type induces a groupoid
structure, as proposed by Hofmann \\&amp; Streicher (1994). Using categorical
semantics, we show that computational paths induce a groupoid structure. We
also show that computational paths are capable of inducing higher categorical
structures.
</summary>
    <author>
      <name>Arthur F. Ramos</name>
    </author>
    <author>
      <name>Ruy J. G. B. de Queiroz</name>
    </author>
    <author>
      <name>Anjolina G. de Oliveira</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages + 2 appendix</arxiv:comment>
    <link href="http://arxiv.org/abs/1506.02721v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1506.02721v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1705.06430v2</id>
    <updated>2017-11-14T18:43:46Z</updated>
    <published>2017-05-18T06:29:49Z</published>
    <title>Cyclic Datatypes modulo Bisimulation based on Second-Order Algebraic
  Theories</title>
    <summary>  Cyclic data structures, such as cyclic lists, in functional programming are
tricky to handle because of their cyclicity. This paper presents an
investigation of categorical, algebraic, and computational foundations of
cyclic datatypes. Our framework of cyclic datatypes is based on second-order
algebraic theories of Fiore et al., which give a uniform setting for syntax,
types, and computation rules for describing and reasoning about cyclic
datatypes. We extract the "fold" computation rules from the categorical
semantics based on iteration categories of Bloom and Esik. Thereby, the rules
are correct by construction. We prove strong normalisation using the General
Schema criterion for second-order computation rules. Rather than the fixed
point law, we particularly choose Bekic law for computation, which is a key to
obtaining strong normalisation. We also prove the property of "Church-Rosser
modulo bisimulation" for the computation rules. Combining these results, we
have a remarkable decidability result of the equational theory of cyclic data
and fold.
</summary>
    <author>
      <name>Makoto Hamana</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.23638/LMCS-13(4:8)2017</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.23638/LMCS-13(4:8)2017" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">38 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 13, Issue 4 (November
  15, 2017) lmcs:4066</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1705.06430v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1705.06430v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; E.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0609037v1</id>
    <updated>2006-09-08T07:35:35Z</updated>
    <published>2006-09-08T07:35:35Z</published>
    <title>(HO)RPO Revisited</title>
    <summary>  The notion of computability closure has been introduced for proving the
termination of the combination of higher-order rewriting and beta-reduction. It
is also used for strengthening the higher-order recursive path ordering. In the
present paper, we study in more details the relations between the computability
closure and the (higher-order) recursive path ordering. We show that the
first-order recursive path ordering is equal to an ordering naturally defined
from the computability closure. In the higher-order case, we get an ordering
containing the higher-order recursive path ordering whose well-foundedness
relies on the correctness of the computability closure. This provides a simple
way to extend the higher-order recursive path ordering to richer type systems.
</summary>
    <author>
      <name>Frédéric Blanqui</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Lorraine - LORIA</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/cs/0609037v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0609037v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0907.3230v1</id>
    <updated>2009-07-20T15:06:12Z</updated>
    <published>2009-07-20T15:06:12Z</published>
    <title>Infinite Oracle Queries in Type-2 Machines (Extended Abstract)</title>
    <summary>  We define Oracle-Type-2-Machine capable of writing infinite oracle queries.
In contrast to finite oracle queries, this extends the realm of
oracle-computable functions into the discontinuous realm. Our definition is
conservative; access to a computable oracle does not increase the computational
power.
  Other models of real hypercomputation such as Ziegler's (finitely) revising
computation or Type-2-Nondeterminism are shown to be special cases of
Oracle-Type-2-Machines. Our approach offers an intuitive definition of the
weakest machine model capable to simulate both Type-2-Machines and BSS
machines.
</summary>
    <author>
      <name>Arno Pauly</name>
    </author>
    <link href="http://arxiv.org/abs/0907.3230v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0907.3230v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1107.0065v1</id>
    <updated>2011-06-30T21:44:46Z</updated>
    <published>2011-06-30T21:44:46Z</published>
    <title>Typed lambda-terms in categorical attributed graph transformation</title>
    <summary>  This paper deals with model transformation based on attributed graph
rewriting. Our contribution investigates a single pushout approach for applying
the rewrite rules. The computation of graph attributes is obtained through the
use of typed lambda-calculus with inductive types. In this paper we present
solutions to cope with single pushout construction for the graph structure and
the computations functions. As this rewrite system uses inductive types, the
expressiveness of attribute computations is facilitated and appears more
efficient than the one based on Sigma-algebras. Some examples showing the
interest of our computation approach are described in this paper.
</summary>
    <author>
      <name>Bertrand Boisvert</name>
    </author>
    <author>
      <name>Louis Féraud</name>
    </author>
    <author>
      <name>Sergei Soloviev</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.56.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.56.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings AMMSE 2011, arXiv:1106.5962</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 56, 2011, pp. 33-47</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1107.0065v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1107.0065v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.01785v3</id>
    <updated>2017-02-20T06:17:38Z</updated>
    <published>2016-08-05T07:25:19Z</published>
    <title>Molecular Model Checking a Temporal Logic</title>
    <summary>  The molecular computing has been successfully employed to solve more and more
complex computation problems. However, as an important complex problem, the
model checking are still far from fully resolved under the circumstance of
molecular computing, since it is still a lack of method. To address this issue,
a model checking method is presented for checking the basic constructs in a
given temporal logic using molecular computing. Through the design of the new
encoding and calling this process, we get a molecule-based approach for
checking all of the basic constructs of this logic.
</summary>
    <author>
      <name>Weijun Zhu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages, 10 figures and 8 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/1608.01785v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.01785v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1505.02091v5</id>
    <updated>2018-05-20T09:15:39Z</updated>
    <published>2015-05-08T16:26:07Z</published>
    <title>Weihrauch-completeness for layerwise computability</title>
    <summary>  We introduce the notion of being Weihrauch-complete for layerwise
computability and provide several natural examples related to complex
oscillations, the law of the iterated logarithm and Birkhoff's theorem. We also
consider hitting time operators, which share the Weihrauch degree of the former
examples but fail to be layerwise computable.
</summary>
    <author>
      <name>Arno Pauly</name>
    </author>
    <author>
      <name>Willem Fouché</name>
    </author>
    <author>
      <name>George Davie</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.23638/LMCS-14(2:11)2018</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.23638/LMCS-14(2:11)2018" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 14, Issue 2 (May 22,
  2018) lmcs:4519</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1505.02091v5" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1505.02091v5" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1703.07748v1</id>
    <updated>2017-03-22T17:01:17Z</updated>
    <published>2017-03-22T17:01:17Z</published>
    <title>Quantum Turing Machines Computations and Measurements</title>
    <summary>  We propose a new formulation of Quantum Turing Ma- chines, as an extension of
those proposed by Bernstein and Vazirani. For this new class of Quantum Turing
Machines, both finite and infinite computations are meaningful -an infinite
computation does not correspond trivially to a divergent function. Moreover, we
propose a natural observation protocol for the new QTMs, that does not modify
the probability of the possible outcomes of the machines. Finally, we use QTMs
to define a class of quantum computable functions - any such a function is a
mapping from a general quantum state to a distribution of probability of
natural numbers.
</summary>
    <author>
      <name>Stefano Guerrini</name>
    </author>
    <author>
      <name>Simone Martini</name>
    </author>
    <author>
      <name>Andrea Masini</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: substantial text overlap with arXiv:1504.02817</arxiv:comment>
    <link href="http://arxiv.org/abs/1703.07748v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1703.07748v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0710.4695v1</id>
    <updated>2007-10-25T09:15:10Z</updated>
    <published>2007-10-25T09:15:10Z</published>
    <title>SAT-Based Complete Don't-Care Computation for Network Optimization</title>
    <summary>  This paper describes an improved approach to Boolean network optimization
using internal don't-cares. The improvements concern the type of don't-cares
computed, their scope, and the computation method. Instead of the traditionally
used compatible observability don't-cares (CODCs), we introduce and justify the
use of complete don't-cares (CDC). To ensure the robustness of the don't-care
computation for very large industrial networks, a optional windowing scheme is
implemented that computes substantial subsets of the CDCs in reasonable time.
Finally, we give a SAT-based don't-care computation algorithm that is more
efficient than BDD-based algorithms. Experimental results confirm that these
improvements work well in practice. Complete don't-cares allow for a reduction
in the number of literals compared to the CODCs. Windowing guarantees
robustness, even for very large benchmarks on which previous methods could not
be applied. SAT reduces the runtime and enhances robustness, making don't-cares
affordable for a variety of other Boolean methods applied to the network.
</summary>
    <author>
      <name>Alan Mishchenko</name>
    </author>
    <author>
      <name>Robert K. Brayton</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted on behalf of EDAA (http://www.edaa.com/)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Dans Design, Automation and Test in Europe - DATE'05, Munich :
  Allemagne (2005)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0710.4695v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0710.4695v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.7394v4</id>
    <updated>2013-09-27T11:25:50Z</updated>
    <published>2013-04-27T18:10:36Z</published>
    <title>A Static Analysis Framework for Livelock Freedom in CSP</title>
    <summary>  In a process algebra with hiding and recursion it is possible to create
processes which compute internally without ever communicating with their
environment. Such processes are said to diverge or livelock. In this paper we
show how it is possible to conservatively classify processes as livelock-free
through a static analysis of their syntax. In particular, we present a
collection of rules, based on the inductive structure of terms, which guarantee
livelock-freedom of the denoted process. This gives rise to an algorithm which
conservatively flags processes that can potentially livelock. We illustrate our
approach by applying both BDD-based and SAT-based implementations of our
algorithm to a range of benchmarks, and show that our technique in general
substantially outperforms the model checker FDR whilst exhibiting a low rate of
inconclusive results.
</summary>
    <author>
      <name>Joel Ouaknine</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, Oxford University, UK</arxiv:affiliation>
    </author>
    <author>
      <name>Hristina Palikareva</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computing, Imperial College London, UK</arxiv:affiliation>
    </author>
    <author>
      <name>A. W. Roscoe</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, Oxford University, UK</arxiv:affiliation>
    </author>
    <author>
      <name>James Worrell</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, Oxford University, UK</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-9(3:24)2013</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-9(3:24)2013" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">53 pages, 20 figures</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 9, Issue 3 (September
  23, 2013) lmcs:884</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1304.7394v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.7394v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.08116v1</id>
    <updated>2016-10-25T23:18:39Z</updated>
    <published>2016-10-25T23:18:39Z</published>
    <title>A Higher-order Calculus of Computational Fields</title>
    <summary>  The complexity of large-scale distributed systems, particularly when deployed
in physical space, calls for new mechanisms to address composability and
reusability of collective adaptive behaviour. Computational fields have been
proposed as an effective abstraction to fill the gap between the macro-level of
such systems (specifying a system's collective behaviour) and the micro-level
(individual devices' actions of computation and interaction to implement that
collective specification), thereby providing a basis to better facilitate the
engineering of collective APIs and complex systems at higher levels of
abstraction. This paper proposes a full formal foundation for field
computations, in terms of a core (higher-order) calculus of computational
fields containing a few key syntactic constructs, and equipped with typing,
denotational and operational semantics. Critically, this allows formal
establishment of a link between the micro- and macro-levels of collective
adaptive systems, by a result of full abstraction and adequacy for the
(aggregate) denotational semantics with respect to the (per-device) operational
semantics.
</summary>
    <author>
      <name>Mirko Viroli</name>
    </author>
    <author>
      <name>Giorgio Audrito</name>
    </author>
    <author>
      <name>Ferruccio Damiani</name>
    </author>
    <author>
      <name>Danilo Pianini</name>
    </author>
    <author>
      <name>Jacob Beal</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">39 pages, 12 figures</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">ACM Transactions on Computational Logic (TOCL), 20(1), Article 5,
  January 2019</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1610.08116v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.08116v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1609.07972v1</id>
    <updated>2016-09-26T13:54:45Z</updated>
    <published>2016-09-26T13:54:45Z</published>
    <title>A Framework for Algebraic Characterizations in Recursive Analysis</title>
    <summary>  Algebraic characterizations of the computational aspects of functions defined
over the real numbers provide very effective tool to understand what
computability and complexity over the reals, and generally over continuous
spaces, mean. This is relevant for both communities of computer scientists and
mathematical analysts, particularly the latter who do not understand (and/or
like) the language of machines and string encodings. Recursive analysis can be
considered the most standard framework of computation over continuous spaces,
it is however defined in a very machine specific way which does not leave much
to intuitiveness. Recently several characterizations, in the form of function
algebras, of recursively computable functions and some sub-recursive classes
were introduced. These characterizations shed light on the hidden behavior of
recursive analysis as they convert complex computational operations on
sequences of real objects to "simple" intuitive mathematical operations such as
integration or taking limits. The authors previously presented a framework for
obtaining algebraic characterizations at the complexity level over compact
domains. The current paper presents a comprehensive extension to that
framework. Though we focus our attention in this paper on functions defined
over the whole real line, the framework, and accordingly the obtained results,
can be easily extended to functions defined over arbitrary domains.
</summary>
    <author>
      <name>Olivier Bournez</name>
    </author>
    <author>
      <name>Walid Gomaa</name>
    </author>
    <author>
      <name>Emmanuel Hainry</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">38 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1609.07972v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1609.07972v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68Q05, 03D10" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.2, F.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1709.01743v2</id>
    <updated>2017-12-11T12:29:05Z</updated>
    <published>2017-09-06T09:47:09Z</published>
    <title>Distant decimals of $π$</title>
    <summary>  We describe how to compute very far decimals of $$pi$$ and how to provide
formal guarantees that the decimals we compute are correct. In particular, we
report on an experiment where 1 million decimals of $$pi$$ and the billionth
hexadecimal (without the preceding ones) have been computed in a formally
verified way. Three methods have been studied, the first one relying on a
spigot formula to obtain at a reasonable cost only one distant digit (more
precisely a hexadecimal digit, because the numeration basis is 16) and the
other two relying on arithmetic-geometric means. All proofs and computations
can be made inside the Coq system. We detail the new formalized material that
was necessary for this achievement and the techniques employed to guarantee the
accuracy of the computed digits, in spite of the necessity to work with fixed
precision numerical computation.
</summary>
    <author>
      <name>Yves Bertot</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">MARELLE</arxiv:affiliation>
    </author>
    <author>
      <name>Laurence Rideau</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">MARELLE</arxiv:affiliation>
    </author>
    <author>
      <name>Laurent Théry</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">MARELLE</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Automated Reasoning, Springer Verlag, A Para{\\^i}tre</arxiv:comment>
    <link href="http://arxiv.org/abs/1709.01743v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1709.01743v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1603.00978v1</id>
    <updated>2016-03-03T05:34:10Z</updated>
    <published>2016-03-03T05:34:10Z</published>
    <title>Finiteness and Computation in Toposes</title>
    <summary>  Some notions in mathematics can be considered relative. Relative is a term
used to denote when the variation in the position of an observer implies
variation in properties or measures on the observed object. We know, from
Skolem theorem, that there are first-order models where the set of real numbers
is countable and some where it is not. This fact depends on the position of the
observer and on the instrument/language the obserevr uses as well, i.e., it
depends on whether he/she is inside the model or not and in this particular
case the use of first-order logic. In this article, we assume that computation
is based on finiteness rather than natural numbers and discuss Turing machines
computable morphisms defined on top of the sole notion finiteness. We explore
the relativity of finiteness in models provided by toposes where the Axiom of
Choice (AC) does not hold, since Tarski proved that if AC holds then all
finiteness notions are equivalent. Our toposes do not have natural numbers
object (NNO) either, since in a topos with a NNO these finiteness notions are
equivalent to Peano finiteness going back to computation on top of Natural
Numbers. The main contribution of this article is to show that although from
inside every topos, with the properties previously stated, the computation
model is standard, from outside some of these toposes, unexpected properties on
the computation arise, e.g., infinitely long programs, finite computations
containing infinitely long ones, infinitely branching computations. We mainly
consider Dedekind and Kuratowski notions of finiteness in this article.
</summary>
    <author>
      <name>Edward Hermann Haeusler</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Puc-Rio</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.204.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.204.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings DCM 2015, arXiv:1603.00536</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 204, 2016, pp. 61-77</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1603.00978v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1603.00978v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1;F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0609110v1</id>
    <updated>2006-09-19T15:21:08Z</updated>
    <published>2006-09-19T15:21:08Z</published>
    <title>Algebraic recognizability of languages</title>
    <summary>  Recognizable languages of finite words are part of every computer science
cursus, and they are routinely described as a cornerstone for applications and
for theory. We would like to briefly explore why that is, and how this
word-related notion extends to more complex models, such as those developed for
modeling distributed or timed behaviors.
</summary>
    <author>
      <name>Pascal Weil</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LaBRI</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Mathematical Foundations of Computer Science 2004, Tch\'{e}que,
  R'{e}publique (2004) 149-175</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0609110v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0609110v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0708.3582v1</id>
    <updated>2007-08-27T12:23:16Z</updated>
    <published>2007-08-27T12:23:16Z</published>
    <title>HORPO with Computability Closure : A Reconstruction</title>
    <summary>  This paper provides a new, decidable definition of the higher- order
recursive path ordering in which type comparisons are made only when needed,
therefore eliminating the need for the computability clo- sure, and bound
variables are handled explicitly, making it possible to handle recursors for
arbitrary strictly positive inductive types.
</summary>
    <author>
      <name>Frédéric Blanqui</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Lorraine - LORIA</arxiv:affiliation>
    </author>
    <author>
      <name>Jean-Pierre Jouannaud</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIX</arxiv:affiliation>
    </author>
    <author>
      <name>Albert Rubio</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Dans 14th International Conference on Logic for Programming
  Artificial Intelligence and Reasoning LNCS (2007)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0708.3582v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0708.3582v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1103.3321v1</id>
    <updated>2011-03-17T00:19:42Z</updated>
    <published>2011-03-17T00:19:42Z</published>
    <title>Typed Operational Semantics for Dependent Record Types</title>
    <summary>  Typed operational semantics is a method developed by H. Goguen to prove
meta-theoretic properties of type systems. This paper studies the metatheory of
a type system with dependent record types, using the approach of typed
operational semantics. In particular, the metatheoretical properties we have
proved include strong normalisation, Church-Rosser and subject reduction.
</summary>
    <author>
      <name>Yangyue Feng</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, RHUL</arxiv:affiliation>
    </author>
    <author>
      <name>Zhaohui Luo</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, RHUL</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.53.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.53.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TYPES 2009, arXiv:1103.3111</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 53, 2011, pp. 30-46</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1103.3321v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1103.3321v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.2295v1</id>
    <updated>2013-05-10T09:34:15Z</updated>
    <published>2013-05-10T09:34:15Z</published>
    <title>An Epistemic Perspective on Consistency of Concurrent Computations</title>
    <summary>  Consistency properties of concurrent computations, e.g., sequential
consistency, linearizability, or eventual consistency, are essential for
devising correct concurrent algorithms. In this paper, we present a logical
formalization of such consistency properties that is based on a standard logic
of knowledge. Our formalization provides a declarative perspective on what is
imposed by consistency requirements and provides some interesting unifying
insight on differently looking properties.
</summary>
    <author>
      <name>Klaus v. Gleissenthall</name>
    </author>
    <author>
      <name>Andrey Rybalchenko</name>
    </author>
    <link href="http://arxiv.org/abs/1305.2295v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.2295v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1503.05025v1</id>
    <updated>2015-03-17T12:56:59Z</updated>
    <published>2015-03-17T12:56:59Z</published>
    <title>A Rice-like theorem for primitive recursive functions</title>
    <summary>  We provide an explicit characterization of the properties of primitive
recursive functions that are decidable or semi-decidable, given a primitive
recursive index for the function. The result is much more general as it applies
to any c.e. class of total computable functions. This is an analog of Rice and
Rice-Shapiro theorem, for restricted classes of total computable functions.
</summary>
    <author>
      <name>Mathieu Hoyrup</name>
    </author>
    <link href="http://arxiv.org/abs/1503.05025v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1503.05025v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.04786v1</id>
    <updated>2016-06-15T14:41:36Z</updated>
    <published>2016-06-15T14:41:36Z</published>
    <title>A Survey of Satisfiability Modulo Theory</title>
    <summary>  Satisfiability modulo theory (SMT) consists in testing the satisfiability of
first-order formulas over linear integer or real arithmetic, or other theories.
In this survey, we explain the combination of propositional satisfiability and
decision procedures for conjunctions known as DPLL(T), and the alternative
"natural domain" approaches. We also cover quantifiers, Craig interpolants,
polynomial arithmetic, and how SMT solvers are used in automated software
analysis.
</summary>
    <author>
      <name>David Monniaux</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Computer Algebra in Scientific Computing, Sep 2016, Bucharest,
  Romania. 2016</arxiv:comment>
    <link href="http://arxiv.org/abs/1606.04786v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.04786v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.09186v1</id>
    <updated>2015-11-30T07:46:43Z</updated>
    <published>2015-11-30T07:46:43Z</published>
    <title>An Algebraic Approach for Approximity</title>
    <summary>  Comparison to traditionally accurate computing, approximate computing focuses
on the rapidity of the satisfactory solution, but not the unnecessary accuracy
of the solution. Approximate bisimularity is the approximate one corresponding
to traditionally accurate bisimilarity. Based on the work of distances between
basic processes, we propose an algebraic approach for distances between
processes to support a whole process calculus CCS, which contains prefix, sum,
composition, restriction, relabeling and recursion.
</summary>
    <author>
      <name>Yong Wang</name>
    </author>
    <link href="http://arxiv.org/abs/1511.09186v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.09186v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1701.03602v1</id>
    <updated>2017-01-13T09:28:04Z</updated>
    <published>2017-01-13T09:28:04Z</published>
    <title>Automatic verification and interactive theorem proving</title>
    <summary>  Automatic verification deals with the validation by means of computers of
correctness certificates. The related tools, usually called proof assistants or
interactive provers, provide an interactive environment for the creation of
formal certificates whose correctness can be assessed in a purely automatic
way. Such systems have applications both in mathematics, where certificates are
proofs of theorems, and in computer science, where certificates testify the
correctness of a given software with respect to its specification.
</summary>
    <author>
      <name>Andrea Asperti</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">in Italian</arxiv:comment>
    <link href="http://arxiv.org/abs/1701.03602v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1701.03602v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1812.05851v1</id>
    <updated>2018-12-14T10:34:43Z</updated>
    <published>2018-12-14T10:34:43Z</published>
    <title>Computational interpretations of classical reasoning: From the epsilon
  calculus to stateful programs</title>
    <summary>  The problem of giving a computational meaning to classical reasoning lies at
the heart of logic. This article surveys three famous solutions to this problem
- the epsilon calculus, modified realizability and the dialectica
interpretation - and re-examines them from a modern perspective, with a
particular emphasis on connections with algorithms and programming.
</summary>
    <author>
      <name>Thomas Powell</name>
    </author>
    <link href="http://arxiv.org/abs/1812.05851v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1812.05851v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.01431v3</id>
    <updated>2019-08-21T15:06:56Z</updated>
    <published>2019-04-01T13:38:28Z</published>
    <title>Fundamentals of computability logic</title>
    <summary>  This article is a semitutorial-style survey of computability logic. An
extended online version of it is maintained at
http://www.csc.villanova.edu/~japaridz/CL/ .
</summary>
    <author>
      <name>Giorgi Japaridze</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: substantial text overlap with arXiv:1612.04513;
  text overlap with arXiv:1107.3706, arXiv:1107.2284 by other authors</arxiv:comment>
    <link href="http://arxiv.org/abs/1904.01431v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.01431v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03B47, 03B70, 03F03, 68T15" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.1.2; F.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1905.08664v1</id>
    <updated>2019-05-21T14:26:01Z</updated>
    <published>2019-05-21T14:26:01Z</published>
    <title>Termination of Triangular Integer Loops is Decidable</title>
    <summary>  We consider the problem whether termination of affine integer loops is
decidable. Since Tiwari conjectured decidability in 2004, only special cases
have been solved. We complement this work by proving decidability for the case
that the update matrix is triangular.
</summary>
    <author>
      <name>Florian Frohn</name>
    </author>
    <author>
      <name>Jürgen Giesl</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Full version (with proofs) of a paper published in the Proceedings of
  the 31st International Conference on Computer Aided Verification (CAV '19),
  New York, NY, USA, Lecture Notes in Computer Science, Springer-Verlag, 2019</arxiv:comment>
    <link href="http://arxiv.org/abs/1905.08664v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1905.08664v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0710.3764v1</id>
    <updated>2007-10-19T19:32:39Z</updated>
    <published>2007-10-19T19:32:39Z</published>
    <title>Design of a Distributed Reachability Algorithm for Analysis of Linear
  Hybrid Automata</title>
    <summary>  This paper presents the design of a novel distributed algorithm d-IRA for the
reachability analysis of linear hybrid automata. Recent work on iterative
relaxation abstraction (IRA) is leveraged to distribute the computational
problem among multiple computational nodes in a non-redundant manner by
performing careful infeasibility analysis of linear programs corresponding to
spurious counterexamples. The d-IRA algorithm is resistant to failure of
multiple computational nodes. The experimental results provide promising
evidence for the possible successful application of this technique.
</summary>
    <author>
      <name>Sumit Kumar Jha</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0710.3764v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0710.3764v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0806.2517v1</id>
    <updated>2008-06-16T11:39:25Z</updated>
    <published>2008-06-16T11:39:25Z</published>
    <title>The computability path ordering: the end of a quest</title>
    <summary>  In this paper, we first briefly survey automated termination proof methods
for higher-order calculi. We then concentrate on the higher-order recursive
path ordering, for which we provide an improved definition, the Computability
Path Ordering. This new definition appears indeed to capture the essence of
computability arguments \'a la Tait and Girard, therefore explaining the name
of the improved ordering.
</summary>
    <author>
      <name>Frédéric Blanqui</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Lorraine - LORIA</arxiv:affiliation>
    </author>
    <author>
      <name>Jean-Pierre Jouannaud</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIX, INRIA Saclay Ile de France</arxiv:affiliation>
    </author>
    <author>
      <name>Albert Rubio</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Dans CSL'08 (2008)</arxiv:comment>
    <link href="http://arxiv.org/abs/0806.2517v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0806.2517v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0902.1587v1</id>
    <updated>2009-02-10T06:42:24Z</updated>
    <published>2009-02-10T06:42:24Z</published>
    <title>Forward analysis for WSTS, Part I: Completions</title>
    <summary>  Well-structured transition systems provide the right foundation to compute a
finite basis of the set of predecessors of the upward closure of a state. The
dual problem, to compute a finite representation of the set of successors of
the downward closure of a state, is harder: Until now, the theoretical
framework for manipulating downward-closed sets was missing. We answer this
problem, using insights from domain theory (dcpos and ideal completions), from
topology (sobrifications), and shed new light on the notion of adequate domains
of limits.
</summary>
    <author>
      <name>Alain Finkel</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LSV</arxiv:affiliation>
    </author>
    <author>
      <name>Jean Goubault-Larrecq</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LSV</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">26th International Symposium on Theoretical Aspects of Computer
  Science - STACS 2009 (2009) 433-444</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0902.1587v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0902.1587v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0904.1488v1</id>
    <updated>2009-04-09T09:40:33Z</updated>
    <published>2009-04-09T09:40:33Z</published>
    <title>Computing Stuttering Simulations</title>
    <summary>  Stuttering bisimulation is a well-known behavioral equivalence that preserves
CTL-X, namely CTL without the next-time operator X. Correspondingly, the
stuttering simulation preorder induces a coarser behavioral equivalence that
preserves the existential fragment ECTL-{X,G}, namely ECTL without the
next-time X and globally G operators. While stuttering bisimulation equivalence
can be computed by the well-known Groote and Vaandrager's [1990] algorithm, to
the best of our knowledge, no algorithm for computing the stuttering simulation
preorder and equivalence is available. This paper presents such an algorithm
for finite state systems.
</summary>
    <author>
      <name>Francesco Ranzato</name>
    </author>
    <author>
      <name>Francesco Tapparo</name>
    </author>
    <link href="http://arxiv.org/abs/0904.1488v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0904.1488v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0904.2340v2</id>
    <updated>2009-06-22T11:30:11Z</updated>
    <published>2009-04-15T15:55:56Z</published>
    <title>Explicit fairness in testing semantics</title>
    <summary>  In this paper we investigate fair computations in the pi-calculus. Following
Costa and Stirling's approach for CCS-like languages, we consider a method to
label process actions in order to filter out unfair computations. We contrast
the existing fair-testing notion with those that naturally arise by imposing
weak and strong fairness. This comparison provides insight about the
expressiveness of the various `fair' testing semantics and about their
discriminating power.
</summary>
    <author>
      <name>D. Cacciagrano</name>
    </author>
    <author>
      <name>F. Corradini</name>
    </author>
    <author>
      <name>C. Palamidessi</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-5(2:15)2009</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-5(2:15)2009" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">27 pages, 1 figure, appeared in LMCS</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 5, Issue 2 (June 22,
  2009) lmcs:1134</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0904.2340v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0904.2340v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.2; D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1006.5561v2</id>
    <updated>2010-09-02T04:27:49Z</updated>
    <published>2010-06-29T10:40:29Z</published>
    <title>Domain Representable Spaces Defined by Strictly Positive Induction</title>
    <summary>  Recursive domain equations have natural solutions. In particular there are
domains defined by strictly positive induction. The class of countably based
domains gives a computability theory for possibly non-countably based
topological spaces. A $ qcb_{0} $ space is a topological space characterized by
its strong representability over domains. In this paper, we study strictly
positive inductive definitions for $ qcb_{0} $ spaces by means of domain
representations, i.e. we show that there exists a canonical fixed point of
every strictly positive operation on $qcb_{0} $ spaces.
</summary>
    <author>
      <name>Petter Kristian Køber</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Oslo</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-6(3:9)2010</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-6(3:9)2010" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">48 pages. Accepted for publication in Logical Methods in Computer
  Science</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 6, Issue 3 (August 26,
  2010) lmcs:955</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1006.5561v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1006.5561v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1, F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.5468v1</id>
    <updated>2011-09-26T07:50:07Z</updated>
    <published>2011-09-26T07:50:07Z</published>
    <title>Static Dependency Pair Method based on Strong Computability for
  Higher-Order Rewrite Systems</title>
    <summary>  Higher-order rewrite systems (HRSs) and simply-typed term rewriting systems
(STRSs) are computational models of functional programs. We recently proposed
an extremely powerful method, the static dependency pair method, which is based
on the notion of strong computability, in order to prove termination in STRSs.
In this paper, we extend the method to HRSs. Since HRSs include
lambda-abstraction but STRSs do not, we restructure the static dependency pair
method to allow lambda-abstraction, and show that the static dependency pair
method also works well on HRSs without new restrictions.
</summary>
    <author>
      <name>Keiichirou Kusakari</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIAMA</arxiv:affiliation>
    </author>
    <author>
      <name>Yasuo Isogai</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIAMA</arxiv:affiliation>
    </author>
    <author>
      <name>Masahiko Sakai</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIAMA</arxiv:affiliation>
    </author>
    <author>
      <name>Frédéric Blanqui</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIAMA</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">IEICE Transactions on Information and Systems (2009)</arxiv:comment>
    <link href="http://arxiv.org/abs/1109.5468v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.5468v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.7120v2</id>
    <updated>2015-12-18T15:00:05Z</updated>
    <published>2013-05-30T14:14:30Z</published>
    <title>Computations by fly-automata beyond monadic second-order logic</title>
    <summary>  We present logically based methods for constructing XP and FPT graph
algorithms, parametrized by tree-width or clique-width. We will use
fly-automata introduced in a previous article. They make possible to check
properties that are not monadic second-order expressible because their states
may include counters, so that their sets of states may be infinite. We equip
these automata with output functions, so that they can compute values
associated with terms or graphs. Rather than new algorithmic results we present
tools for constructing easily certain dynamic programming algorithms by
combining predefined automata for basic functions and properties.
</summary>
    <author>
      <name>Bruno Courcelle</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LaBRI</arxiv:affiliation>
    </author>
    <author>
      <name>Irène Durand</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted for publication in Theoretical Computer Science</arxiv:comment>
    <link href="http://arxiv.org/abs/1305.7120v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.7120v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1410.7225v1</id>
    <updated>2014-10-27T13:31:45Z</updated>
    <published>2014-10-27T13:31:45Z</published>
    <title>Analyzing Expected Outcomes and Almost-Sure Termination of Probabilistic
  Programs is Hard</title>
    <summary>  This paper considers the computational hardness of computing expected
outcomes and deciding almost-sure termination of probabilistic programs. We
show that deciding almost-sure termination and deciding whether the expected
outcome of a program equals a given rational value is $Pi^0_2$-complete.
Computing lower and upper bounds on the expected outcome is shown to be
recursively enumerable and $Sigma^0_2$-complete, respectively.
</summary>
    <author>
      <name>Benjamin Lucien Kaminski</name>
    </author>
    <author>
      <name>Joost-Pieter Katoen</name>
    </author>
    <link href="http://arxiv.org/abs/1410.7225v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1410.7225v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68Q87" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.2; F.1.3; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1502.05209v2</id>
    <updated>2015-03-02T08:28:12Z</updated>
    <published>2015-02-18T13:02:02Z</published>
    <title>Formalizing Size-Optimal Sorting Networks: Extracting a Certified Proof
  Checker</title>
    <summary>  Since the proof of the four color theorem in 1976, computer-generated proofs
have become a reality in mathematics and computer science. During the last
decade, we have seen formal proofs using verified proof assistants being used
to verify the validity of such proofs.
  In this paper, we describe a formalized theory of size-optimal sorting
networks. From this formalization we extract a certified checker that
successfully verifies computer-generated proofs of optimality on up to 8
inputs. The checker relies on an untrusted oracle to shortcut the search for
witnesses on more than 1.6 million NP-complete subproblems.
</summary>
    <author>
      <name>Luís Cruz-Filipe</name>
    </author>
    <author>
      <name>Peter Schneider-Kamp</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-319-22102-1_10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-319-22102-1_10" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">IMADA-preprint-cs</arxiv:comment>
    <link href="http://arxiv.org/abs/1502.05209v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1502.05209v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1403.4880v1</id>
    <updated>2014-03-19T16:52:20Z</updated>
    <published>2014-03-19T16:52:20Z</published>
    <title>Two Puzzles About Computation</title>
    <summary>  The purpose of this note is to raise two different questions, which are
rarely if ever considered, and to which, it seems, we lack convincing,
systematic answers. These questions can be posed as:
  - Why do we compute?
  - What do we compute?
  The point is not so much that we have no answers to these puzzles, as that we
have no established body of theory which gives satisfying, systematic answers,
as part of a broader understanding. By raising these questions, we hope to
stimulate some thinking in this direction.
</summary>
    <author>
      <name>Samson Abramsky</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">In Alan Turing: his work and impact, ed. S.B. Cooper and J. van
  Leeuwen, pages 53-57, Elsevier 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1403.4880v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1403.4880v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.07047v1</id>
    <updated>2016-06-22T19:23:00Z</updated>
    <published>2016-06-22T19:23:00Z</published>
    <title>Deciding Hyperproperties</title>
    <summary>  Hyperproperties, like observational determinism or symmetry, cannot be
expressed as properties of individual computation traces, because they describe
a relation between multiple computation traces. HyperLTL is a temporal logic
that captures such relations through trace variables, which are introduced
through existential and universal trace quantifiers and can be used to refer to
multiple computations at the same time. In this paper, we study the
satisfiability problem of HyperLTL. We show that the problem is PSPACE-complete
for alternation-free formulas (and, hence, no more expensive than LTL
satisfiability), EXPSPACE-complete for exists-forall-formulas, and undecidable
for forall-exists-formulas. Many practical hyperproperties can be expressed as
alternation-free formulas. Our results show that both satisfiability and
implication are decidable for such properties.
</summary>
    <author>
      <name>Bernd Finkbeiner</name>
    </author>
    <author>
      <name>Christopher Hahn</name>
    </author>
    <link href="http://arxiv.org/abs/1606.07047v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.07047v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1408.2333v2</id>
    <updated>2014-08-25T10:27:35Z</updated>
    <published>2014-08-11T07:22:13Z</published>
    <title>SAT-Based Methods for Circuit Synthesis</title>
    <summary>  Reactive synthesis supports designers by automatically constructing correct
hardware from declarative specifications. Synthesis algorithms usually compute
a strategy, and then construct a circuit that implements it. In this work, we
study SAT- and QBF-based methods for the second step, i.e., computing circuits
from strategies. This includes methods based on QBF-certification,
interpolation, and computational learning. We present optimizations, efficient
implementations, and experimental results for synthesis from safety
specifications, where we outperform BDDs both regarding execution time and
circuit size. This is an extended version of [2], with an additional appendix.
</summary>
    <author>
      <name>Roderick Bloem</name>
    </author>
    <author>
      <name>Uwe Egly</name>
    </author>
    <author>
      <name>Patrick Klampfl</name>
    </author>
    <author>
      <name>Robert Koenighofer</name>
    </author>
    <author>
      <name>Florian Lonsing</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended version of a paper at FMCAD'14</arxiv:comment>
    <link href="http://arxiv.org/abs/1408.2333v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1408.2333v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1411.7139v1</id>
    <updated>2014-11-26T08:38:03Z</updated>
    <published>2014-11-26T08:38:03Z</published>
    <title>Certification of programs with computational effects</title>
    <summary>  In purely functional programming languages imperative features, more
generally computational effects are prohibited. However, non-functional lan-
guages do involve effects. The theory of decorated logic provides a rigorous
for- malism (with a refinement in operation signatures) for proving program
properties with respect to computational effects. The aim of this thesis is to
first develop Coq libraries and tools for verifying program properties in
decorated settings as- sociated with several effects: states, local state,
exceptions, non-termination, etc. Then, these tools will be combined to deal
with several effects.
</summary>
    <author>
      <name>Burak Ekici</name>
    </author>
    <link href="http://arxiv.org/abs/1411.7139v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1411.7139v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1512.08366v2</id>
    <updated>2016-07-13T05:34:57Z</updated>
    <published>2015-12-28T10:24:48Z</published>
    <title>Computing Theory Prime Implicates in Modal Logic</title>
    <summary>  The algorithm to compute theory prime implicates, a generalization of prime
implicates, in propositional logic has been suggested in cite{Marquis}. In
this paper we have extended that algorithm to compute theory prime implicates
of a knowledge base $X$ with respect to another knowledge base $Box Y$ using
cite{Bienvenu}, where $Y$ is a propositional knowledge base and $Xmodels Y$,
in modal system $mathcal{T}$ and we have also proved its correctness. We have
also proved that it is an equivalence preserving knowledge compilation and the
size of theory prime implicates of $X$ with respect to $Box Y$ is less than
the size of the prime implicates of $XcupBox Y$.
</summary>
    <author>
      <name>Manoj K. Raut</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">20 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1512.08366v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1512.08366v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1709.08533v1</id>
    <updated>2017-09-25T15:01:01Z</updated>
    <published>2017-09-25T15:01:01Z</published>
    <title>Intensional Constructed Numbers: Towards Formalizing the Notion of
  Algorithm</title>
    <summary>  This work is meant to be a step towards the formal definition of the notion
of algorithm, in the sense of an equivalence class of programs working "in a
similar way". But instead of defining equivalence transformations directly on
programs, we look at the computation for each particular argument and give it a
structure. This leads to the notion of constructed number: the result of the
computation is a constructed number whose constructors (0, successor) carry a
history condition (or trace) of their computation. There are equivalence
relations on these conditions and on constructed numbers. Two programs are
equivalent if they produce equivalent constructed numbers for each argument.
</summary>
    <author>
      <name>Fritz Müller</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">20 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1709.08533v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1709.08533v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1807.02973v1</id>
    <updated>2018-07-09T07:51:04Z</updated>
    <published>2018-07-09T07:51:04Z</published>
    <title>Petri Net Reductions for Counting Markings</title>
    <summary>  We propose a method to count the number of reachable markings of a Petri net
without having to enumerate these rst. The method relies on a structural
reduction system that reduces the number of places and transitions of the net
in such a way that we can faithfully compute the number of reachable markings
of the original net from the reduced net and the reduction history. The method
has been implemented and computing experiments show that reductions are eective
on a large benchmark of models.
</summary>
    <author>
      <name>Bernard Berthomieu</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LAAS-VERTICS</arxiv:affiliation>
    </author>
    <author>
      <name>Didier Le Botlan</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LAAS-VERTICS</arxiv:affiliation>
    </author>
    <author>
      <name>Silvano Dal Zilio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LAAS-VERTICS</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-319-94111-0_4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-319-94111-0_4" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">International Symposium on Model Checking Software, SPIN 2018, Jun
  2018, Malaga, Spain. Springer, 10869, Lecture Notes in Computer Science</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1807.02973v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1807.02973v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1902.05172v1</id>
    <updated>2019-02-14T00:21:18Z</updated>
    <published>2019-02-14T00:21:18Z</published>
    <title>Computability logic: Giving Caesar what belongs to Caesar</title>
    <summary>  The present article is a brief informal survey of computability logic --- the
game-semantically conceived formal theory of computational resources and tasks.
This relatively young nonclassical logic is a conservative extension of
classical first order logic but is much more expressive than the latter,
yielding a wide range of new potential application areas. In a reasonable (even
if not strict) sense the same holds for intuitionistic and linear logics, which
allows us to say that CoL reconciles and unifies the three traditions of
logical thought (and beyond) on the basis of its natural and "universal" game
semantics. A comprehensive online survey of the subject can be found at
http://www.csc.villanova.edu/~japaridz/CL/ .
</summary>
    <author>
      <name>Giorgi Japaridze</name>
    </author>
    <link href="http://arxiv.org/abs/1902.05172v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1902.05172v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03B47, 03B70, 03F03, 03F20, 68T15" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.1.2; F.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.02729v2</id>
    <updated>2019-05-06T16:43:12Z</updated>
    <published>2019-04-04T18:09:27Z</published>
    <title>Towards Specifying Symbolic Computation</title>
    <summary>  Many interesting and useful symbolic computation algorithms manipulate
mathematical expressions in mathematically meaningful ways. Although these
algorithms are commonplace in computer algebra systems, they can be
surprisingly difficult to specify in a formal logic since they involve an
interplay of syntax and semantics. In this paper we discuss several examples of
syntax-based mathematical algorithms, and we show how to specify them in a
formal logic with undefinedness, quotation, and evaluation.
</summary>
    <author>
      <name>Jacques Carette</name>
    </author>
    <author>
      <name>William M. Farmer</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">16 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1904.02729v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.02729v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03B15 (Primary), 03B15, 68T30 (Secondary)" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1; I.1.0; I.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.08943v1</id>
    <updated>2019-10-20T10:13:34Z</updated>
    <published>2019-10-20T10:13:34Z</published>
    <title>Computing Branching Distances Using Quantitative Games</title>
    <summary>  We lay out a general method for computing branching distances between labeled
transition systems. We translate the quantitative games used for defining these
distances to other, path-building games which are amenable to methods from the
theory of quantitative games. We then show for all common types of branching
distances how the resulting path-building games can be solved. In the end, we
achieve a method which can be used to compute all branching distances in the
linear-time--branching-time spectrum.
</summary>
    <author>
      <name>Uli Fahrenberg</name>
    </author>
    <author>
      <name>Axel Legay</name>
    </author>
    <author>
      <name>Karin Quaas</name>
    </author>
    <link href="http://arxiv.org/abs/1910.08943v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.08943v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0305011v1</id>
    <updated>2003-05-15T10:46:00Z</updated>
    <published>2003-05-15T10:46:00Z</published>
    <title>Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary
  Affine Logic</title>
    <summary>  We present a type inference algorithm for lambda-terms in Elementary Affine
Logic using linear constraints. We prove that the algorithm is correct and
complete.
</summary>
    <author>
      <name>Paolo Coppola</name>
    </author>
    <author>
      <name>Simone Martini</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">ACM Transactions on Computational Logic, vol 7 (2006) pp. 219 -
  260.</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0305011v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0305011v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1: D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1003.5716v1</id>
    <updated>2010-03-30T01:48:23Z</updated>
    <published>2010-03-30T01:48:23Z</published>
    <title>Proceedings First International Workshop on Linearity</title>
    <summary>  This volume contains the proceedings of LINEARITY 2009: the first
International Workshop on Linearity, which took place 12th September 2009 in
Coimbra, Portugal. The workshop was a satellite event of CSL 2009, the 18th
EACSL Annual Conference on Computer Science Logic.
</summary>
    <author>
      <name>Mário Florido</name>
    </author>
    <author>
      <name>Ian Mackie</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.22</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.22" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 22, 2010</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1003.5716v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1003.5716v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1401.1849v4</id>
    <updated>2015-03-24T09:05:44Z</updated>
    <published>2014-01-08T22:24:10Z</published>
    <title>The Computational Complexity of Propositional Cirquent Calculus</title>
    <summary>  Introduced in 2006 by Japaridze, cirquent calculus is a refinement of sequent
calculus. The advent of cirquent calculus arose from the need for a deductive
system with a more explicit ability to reason about resources. Unlike the more
traditional proof-theoretic approaches that manipulate tree-like objects
(formulas, sequents, etc.), cirquent calculus is based on circuit-style
structures called cirquents, in which different "peer" (sibling, cousin, etc.)
substructures may share components. It is this resource sharing mechanism to
which cirquent calculus owes its novelty (and its virtues). From its inception,
cirquent calculus has been paired with an abstract resource semantics. This
semantics allows for reasoning about the interaction between a resource
provider and a resource user, where resources are understood in the their most
general and intuitive sense. Interpreting resources in a more restricted
computational sense has made cirquent calculus instrumental in axiomatizing
various fundamental fragments of Computability Logic, a formal theory of
(interactive) computability. The so-called "classical" rules of cirquent
calculus, in the absence of the particularly troublesome contraction rule,
produce a sound and complete system CL5 for Computability Logic. In this paper,
we investigate the computational complexity of CL5, showing it is
$Sigma_2^p$-complete. We also show that CL5 without the duplication rule has
polynomial size proofs and is NP-complete.
</summary>
    <author>
      <name>Matthew Steven Bauer</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Illinois at Urbana-Champaign</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-11(1:12)2015</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-11(1:12)2015" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 11, Issue 1 (March 25,
  2015) lmcs:1127</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1401.1849v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1401.1849v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1401.4973v1</id>
    <updated>2014-01-20T16:35:23Z</updated>
    <published>2014-01-20T16:35:23Z</published>
    <title>What are the fundamental structures of concurrency? We still don't know!</title>
    <summary>  Process algebra has been successful in many ways; but we don't yet see the
lineaments of a fundamental theory. Some fleeting glimpses are sought from
Petri Nets, physics and geometry.
</summary>
    <author>
      <name>Samson Abramsky</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Electronic Notes in Theoretical Computer Science 162 (2006): 37-41</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1401.4973v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1401.4973v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1604.08873v2</id>
    <updated>2016-06-14T17:48:27Z</updated>
    <published>2016-04-29T15:26:22Z</published>
    <title>Computational Higher Type Theory I: Abstract Cubical Realizability</title>
    <summary>  Brouwer's constructivist foundations of mathematics is based on an
intuitively meaningful notion of computation shared by all mathematicians.
Martin-L\\"of's meaning explanations for constructive type theory define the
concept of a type in terms of computation. Briefly, a type is a complete
(closed) program that evaluates to a canonical type whose members are complete
programs that evaluate to canonical elements of that type. The explanation is
extended to incomplete (open) programs by functionality: types and elements
must respect equality in their free variables. Equality is evidence-free---two
types or elements are at most equal---and equal things are implicitly
interchangeable in all contexts.
  Higher-dimensional type theory extends type theory to account for
identifications of types and elements. An identification witnesses that two
types or elements are explicitly interchangeable in all contexts by an explicit
transport, or coercion, operation. There must be sufficiently many
identifications, which is ensured by imposing a generalized form of the Kan
condition from homotopy theory. Here we provide a Martin-L\\"of-style meaning
explanation of simple higher-dimensional type theory based on a programming
language that includes Kan-like constructs witnessing the computational meaning
of the higher structure of types. The treatment includes an example of a higher
inductive type (namely, the 1-dimensional sphere) and an example of Voevodsky's
univalence principle, which identifies equivalent types.
  The main result is a computational canonicity theorem that validates the
computational interpretation: a closed boolean expression must always evaluate
to a boolean value, even in the presence of higher-dimensional structure. This
provides the first fully computational formulation of higher-dimensional type
theory.
</summary>
    <author>
      <name>Carlo Angiuli</name>
    </author>
    <author>
      <name>Robert Harper</name>
    </author>
    <author>
      <name>Todd Wilson</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">39 pages. v2: added abstract, minor corrections</arxiv:comment>
    <link href="http://arxiv.org/abs/1604.08873v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1604.08873v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1311.5006v1</id>
    <updated>2013-11-20T10:46:35Z</updated>
    <published>2013-11-20T10:46:35Z</published>
    <title>Indagini in Deep Inference</title>
    <summary>  Italian master's thesis in Computer Science. It is an overview of the
standard tecniques developed in the field of Proof Theory, ending with some
results in the new field of Deep Inference, plus an original contribution
trying to relate Deep Inference and Process Algebras.
</summary>
    <author>
      <name>Andrea Simonetto</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">in Italian</arxiv:comment>
    <link href="http://arxiv.org/abs/1311.5006v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1311.5006v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.05797v4</id>
    <updated>2015-09-02T16:20:54Z</updated>
    <published>2015-04-22T13:32:12Z</published>
    <title>Service-Oriented Logic Programming</title>
    <summary>  We develop formal foundations for notions and mechanisms needed to support
service-oriented computing. Our work builds on recent theoretical advancements
in the algebraic structures that capture the way services are orchestrated and
in the processes that formalize the discovery and binding of services to given
client applications by means of logical representations of required and
provided services. We show how the denotational and the operational semantics
specific to conventional logic programming can be generalized using the theory
of institutions to address both static and dynamic aspects of service-oriented
computing. Our results rely upon a strong analogy between the discovery of a
service that can be bound to an application and the search for a clause that
can be used for computing an answer to a query; they explore the manner in
which requests for external services can be described as service queries, and
explain how the computation of their answers can be performed through
service-oriented derivatives of unification and resolution, which characterize
the binding of services and the reconfiguration of applications.
</summary>
    <author>
      <name>Ionut Tutu</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, Royal Holloway University of London</arxiv:affiliation>
    </author>
    <author>
      <name>Jose Luiz Fiadeiro</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, Royal Holloway University of London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-11(3:3)2015</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-11(3:3)2015" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 11, Issue 3 (August
  18, 2015) lmcs:1579</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1504.05797v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.05797v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1512.06233v1</id>
    <updated>2015-12-19T12:29:30Z</updated>
    <published>2015-12-19T12:29:30Z</published>
    <title>Process Realizability</title>
    <summary>  We develop a notion of realizability for Classical Linear Logic based on a
concurrent process calculus.
</summary>
    <author>
      <name>Samson Abramsky</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in Foundations of Secure Computation: Proceedings of the
  1999 Marktoberdorf Summer School, F. L. Bauer and R. Steinbruggen, eds. (IOS
  Press) 2000, 167-180</arxiv:comment>
    <link href="http://arxiv.org/abs/1512.06233v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1512.06233v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1703.03239v1</id>
    <updated>2017-03-09T12:03:29Z</updated>
    <published>2017-03-09T12:03:29Z</published>
    <title>$Σ^μ_2$ is decidable for $Π^μ_2$</title>
    <summary>  Given a $Pi^{mu}_2$ formula of the modal $mu$ calculus, it is decidable
whether it is equivalent to a $Sigma^{mu}_2$ formula.
</summary>
    <author>
      <name>Karoliina Lehtinen</name>
    </author>
    <author>
      <name>Sandra Quickert</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This is the extended pre-print of a paper of the same name accepted
  to Computability in Europe 2017</arxiv:comment>
    <link href="http://arxiv.org/abs/1703.03239v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1703.03239v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.03917v2</id>
    <updated>2019-10-24T08:27:45Z</updated>
    <published>2019-04-08T09:45:29Z</published>
    <title>Fifty years of Hoare's Logic</title>
    <summary>  We present a history of Hoare's logic.
</summary>
    <author>
      <name>Krzysztof R. Apt</name>
    </author>
    <author>
      <name>Ernst-Ruediger Olderog</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">79 pages. To appear in Formal Aspects of Computing</arxiv:comment>
    <link href="http://arxiv.org/abs/1904.03917v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.03917v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1912.00629v1</id>
    <updated>2019-12-02T08:32:59Z</updated>
    <published>2019-12-02T08:32:59Z</published>
    <title>A categorical reduction system for linear logic</title>
    <summary>  We build calculus on the categorical model of linear logic. It enables us to
perform diagram chasing as essentially one-way computations led by rewriting
rules. We verify the termination property of the calculus.
</summary>
    <author>
      <name>Ryu Hasegawa</name>
    </author>
    <link href="http://arxiv.org/abs/1912.00629v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1912.00629v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0011013v1</id>
    <updated>2000-11-08T14:32:48Z</updated>
    <published>2000-11-08T14:32:48Z</published>
    <title>Transformation-Based Bottom-Up Computation of the Well-Founded Model</title>
    <summary>  We present a framework for expressing bottom-up algorithms to compute the
well-founded model of non-disjunctive logic programs. Our method is based on
the notion of conditional facts and elementary program transformations studied
by Brass and Dix for disjunctive programs. However, even if we restrict their
framework to nondisjunctive programs, their residual program can grow to
exponential size, whereas for function-free programs our program remainder is
always polynomial in the size of the extensional database (EDB).
  We show that particular orderings of our transformations (we call them
strategies) correspond to well-known computational methods like the alternating
fixpoint approach, the well-founded magic sets method and the magic alternating
fixpoint procedure. However, due to the confluence of our calculi, we come up
with computations of the well-founded model that are provably better than these
methods.
  In contrast to other approaches, our transformation method treats magic set
transformed programs correctly, i.e. it always computes a relevant part of the
well-founded model of the original program.
</summary>
    <author>
      <name>Stefan Brass</name>
    </author>
    <author>
      <name>Juergen Dix</name>
    </author>
    <author>
      <name>Burkhard Freitag</name>
    </author>
    <author>
      <name>Ulrich Zukowski</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">43 pages, 3 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0011013v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0011013v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.6352v2</id>
    <updated>2012-03-05T15:58:01Z</updated>
    <published>2012-02-28T20:38:20Z</published>
    <title>Theorem proving for prenex Gödel logic with Delta: checking validity
  and unsatisfiability</title>
    <summary>  G\\"odel logic with the projection operator Delta (G_Delta) is an important
many-valued as well as intermediate logic. In contrast to classical logic, the
validity and the satisfiability problems of G_Delta are not directly dual to
each other. We nevertheless provide a uniform, computational treatment of both
problems for prenex formulas by describing appropriate translations into sets
of order clauses that can be subjected to chaining resolution. For validity a
version of Herbrand's Theorem allows us to show the soundness of standard
Skolemization. For satisfiability the translation involves a novel, extended
Skolemization method.
</summary>
    <author>
      <name>Matthias Baaz</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Discrete Mathematics and Geometry, TU Vienna</arxiv:affiliation>
    </author>
    <author>
      <name>Agata Ciabattoni</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Languages, TU Vienna</arxiv:affiliation>
    </author>
    <author>
      <name>Christian G Fermüller</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Languages, TU Vienna</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-8(1:20)2012</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-8(1:20)2012" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">23 pages, accepted for LMCS (Logical Methods in Computer Science)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 8, Issue 1 (March 6,
  2012) lmcs:833</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1202.6352v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.6352v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.2394v2</id>
    <updated>2013-10-30T20:43:15Z</updated>
    <published>2013-09-10T07:20:00Z</published>
    <title>Polynomial Path Orders</title>
    <summary>  This paper is concerned with the complexity analysis of constructor term
rewrite systems and its ramification in implicit computational complexity. We
introduce a path order with multiset status, the polynomial path order POP*,
that is applicable in two related, but distinct contexts. On the one hand POP*
induces polynomial innermost runtime complexity and hence may serve as a
syntactic, and fully automatable, method to analyse the innermost runtime
complexity of term rewrite systems. On the other hand POP* provides an
order-theoretic characterisation of the polytime computable functions: the
polytime computable functions are exactly the functions computable by an
orthogonal constructor TRS compatible with POP*.
</summary>
    <author>
      <name>Martin Avanzini</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Innsbruck, Austria</arxiv:affiliation>
    </author>
    <author>
      <name>Georg Moser</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Innsbruck, Austria</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-9(4:9)2013</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-9(4:9)2013" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">LMCS version. This article supersedes arXiv:1209.3793</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 9, Issue 4 (November
  1, 2013) lmcs:807</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.2394v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.2394v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1509.02826v1</id>
    <updated>2015-09-09T16:02:13Z</updated>
    <published>2015-09-09T16:02:13Z</published>
    <title>Proceedings Tenth International Workshop on Fixed Points in Computer
  Science</title>
    <summary>  This volume contains the proceedings of the Tenth International Workshop on
Fixed Points in Computer Science (FICS 2015) which took place on September 11th
and 12th, 2015 in Berlin, Germany, as a satellite event of the conference
Computer Science Logic (CSL 2015).
  Fixed points play a fundamental role in several areas of computer science.
They are used to justify (co)recursive definitions and associated reasoning
techniques. The construction and properties of fixed points have been
investigated in many different settings such as: design and implementation of
programming languages, logics, verification, databases. The aim of this
workshop is to provide a forum for researchers to present their results to
those members of the computer science and logic communities who study or apply
the theory of fixed points.
  Each of the 11 contributed papers of this volume were evaluated by three or
four reviewers. Some of the papers were re-reviewed after revision.
  Additionally, this volume contains the abstracts of the FICS 2015 invited
talks given by Bartek Klin and James Worrell.
</summary>
    <author>
      <name>Ralph Matthes</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IRIT - CNRS &amp; Univ. of Toulouse</arxiv:affiliation>
    </author>
    <author>
      <name>Matteo Mio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CNRS &amp; ENS Lyon</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.191</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.191" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 191, 2015</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1509.02826v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1509.02826v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1601.01546v2</id>
    <updated>2016-01-11T10:33:57Z</updated>
    <published>2016-01-07T14:38:51Z</published>
    <title>On the Executability of Interactive Computation</title>
    <summary>  The model of interactive Turing machines (ITMs) has been proposed to
characterise which stream translations are interactively computable; the model
of reactive Turing machines (RTMs) has been proposed to characterise which
behaviours are reactively executable. In this article we provide a comparison
of the two models. We show, on the one hand, that the behaviour exhibited by
ITMs is reactively executable, and, on the other hand, that the stream
translations naturally associated with RTMs are interactively computable. We
conclude from these results that the theory of reactive executability subsumes
the theory of interactive computability. Inspired by the existing model of ITMs
with advice, which provides a model of evolving computation, we also consider
RTMs with advice and we establish that a facility of advice considerably
upgrades the behavioural expressiveness of RTMs: every countable transition
system can be simulated by some RTM with advice up to a fine notion of
behavioural equivalence.
</summary>
    <author>
      <name>Bas Luttik</name>
    </author>
    <author>
      <name>Fei Yang</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 0 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1601.01546v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1601.01546v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1602.03597v1</id>
    <updated>2016-02-11T01:20:48Z</updated>
    <published>2016-02-11T01:20:48Z</published>
    <title>Communicating machines as a dynamic binding mechanism of services</title>
    <summary>  Distributed software is becoming more and more dynamic to support
applications able to respond and adapt to the changes of their execution
environment. For instance, service-oriented computing (SOC) envisages
applications as services running over globally available computational
resources where discovery and binding between them is transparently performed
by a middleware. Asynchronous Relational Networks (ARNs) is a well-known formal
orchestration model, based on hypergraphs, for the description of
service-oriented software artefacts. Choreography and orchestration are the two
main design principles for the development of distributed software. In this
work, we propose Communicating Relational Networks (CRNs), which is a variant
of ARNs, but relies on choreographies for the characterisation of the
communicational aspects of a software artefact, and for making their automated
analysis more efficient.
</summary>
    <author>
      <name>Ignacio Vissani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of computing, School of Science, Universidad de Buenos Aires</arxiv:affiliation>
    </author>
    <author>
      <name>Carlos Gustavo Lopez Pombo</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of computing, School of Science, Universidad de Buenos Aires and Consejo Nacional de Investigaciones Científicas y Tecnológicas</arxiv:affiliation>
    </author>
    <author>
      <name>Emilio Tuosto</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, University of Leicester</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.203.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.203.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2015, arXiv:1602.03254</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 203, 2016, pp. 85-98</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1602.03597v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1602.03597v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1311.6542v1</id>
    <updated>2013-11-26T02:09:41Z</updated>
    <published>2013-11-26T02:09:41Z</published>
    <title>Implementing program extraction from CL1-proofs</title>
    <summary>  Computability logic (CoL) is a formal theory of interactive computation. It
understands computational problems as games played by two players: a machine
and its environment, uses logical formalism to describe valid principles of
computability and formulas to represent computational problems. Logic CL1 is a
deductive system for a fragment of CoL. The logical vocabulary contains all of
the operators of classical logic and choice operators, the atoms represent
elementary games i.e. predicates of classical logic. In this paper, we present
a program that takes a CL1-proof of an arbitrary formula $F$, and extract a
winning strategy for $F$ from that proof then play $F$ using that strategy. We
hope this paper would provide a starting point for further work in program
extraction of the CoL-based arithmetic and other CoL-based applied systems.
</summary>
    <author>
      <name>Meixia Qu</name>
    </author>
    <author>
      <name>Ke Chen</name>
    </author>
    <author>
      <name>Daming Zhu</name>
    </author>
    <author>
      <name>Junfeng Luan</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">1 figure</arxiv:comment>
    <link href="http://arxiv.org/abs/1311.6542v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1311.6542v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1411.3995v2</id>
    <updated>2014-12-22T21:31:25Z</updated>
    <published>2014-11-14T17:58:55Z</published>
    <title>Sub-computable Boundedness Randomness</title>
    <summary>  This paper defines a new notion of bounded computable randomness for certain
classes of sub-computable functions which lack a universal machine. In
particular, we define such versions of randomness for primitive recursive
functions and for PSPACE functions. These new notions are robust in that there
are equivalent formulations in terms of (1) Martin-L\\"of tests, (2) Kolmogorov
complexity, and (3) martingales. We show these notions can be equivalently
defined with prefix-free Kolmogorov complexity. We prove that one direction of
van Lambalgen's theorem holds for relative computability, but the other
direction fails. We discuss statistical properties of these notions of
randomness.
</summary>
    <author>
      <name>Sam Buss</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of California, San Diego</arxiv:affiliation>
    </author>
    <author>
      <name>Douglas Cenzer</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Florida</arxiv:affiliation>
    </author>
    <author>
      <name>Jeffrey B. Remmel</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of California, San Deigo</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-10(4:15)2014</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-10(4:15)2014" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 10, Issue 4 (December
  24, 2014) lmcs:979</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1411.3995v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1411.3995v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1801.07528v4</id>
    <updated>2019-03-27T18:34:10Z</updated>
    <published>2018-01-23T13:26:35Z</published>
    <title>Computer-Assisted Proving of Combinatorial Conjectures Over Finite
  Domains: A Case Study of a Chess Conjecture</title>
    <summary>  There are several approaches for using computers in deriving mathematical
proofs. For their illustration, we provide an in-depth study of using computer
support for proving one complex combinatorial conjecture -- correctness of a
strategy for the chess KRK endgame. The final, machine verifiable, result
presented in this paper is that there is a winning strategy for white in the
KRK endgame generalized to $n times n$ board (for natural $n$ greater than
$3$). We demonstrate that different approaches for computer-based theorem
proving work best together and in synergy and that the technology currently
available is powerful enough for providing significant help to humans deriving
complex proofs.
</summary>
    <author>
      <name>Predrag Janičić</name>
    </author>
    <author>
      <name>Filip Marić</name>
    </author>
    <author>
      <name>Marko Maliković</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.23638/LMCS-15(1:34)2019</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.23638/LMCS-15(1:34)2019" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 15, Issue 1 (March 29,
  2019) lmcs:5328</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1801.07528v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1801.07528v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03B35, 68T15" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1804.03121v2</id>
    <updated>2018-04-13T16:46:43Z</updated>
    <published>2018-04-09T17:40:09Z</published>
    <title>Full version: An evaluation of estimation techniques for probabilistic
  reachability</title>
    <summary>  We evaluate numerically-precise Monte Carlo (MC), Quasi-Monte Carlo (QMC) and
Randomised Quasi-Monte Carlo (RQMC) methods for computing probabilistic
reachability in hybrid systems with random parameters. Computing reachability
probability amounts to computing (multidimensional) integrals. In particular,
we pay attention to QMC methods due to their theoretical benefits in
convergence speed with respect to the MC method. The Koksma-Hlawka inequality
is a standard result that bounds the approximation of an integral by QMC
techniques. However, it is not useful in practice because it depends on the
variation of the integrand function, which is in general difficult to compute.
The question arises whether it is possible to apply statistical or empirical
methods for estimating the approximation error. In this paper we compare a
number of interval estimation techniques based on the Central Limit Theorem
(CLT), and we also introduce a new approach based on the CLT for computing
confidence intervals for probability near the borders of the [0,1] interval.
Based on our analysis, we provide justification for the use of the developed
approach and suggest usage guidelines for probability estimation techniques.
</summary>
    <author>
      <name>Mariia Vasileva</name>
    </author>
    <author>
      <name>Paolo Zuliani</name>
    </author>
    <link href="http://arxiv.org/abs/1804.03121v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1804.03121v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1804.04607v1</id>
    <updated>2018-04-10T11:11:00Z</updated>
    <published>2018-04-10T11:11:00Z</published>
    <title>Reversible Computation in Petri Nets</title>
    <summary>  Reversible computation is an unconventional form of computing where any
executed sequence of operations can be executed in reverse at any point during
computation. It has recently been attracting increasing attention in various
research communities as on the one hand it promises low-power computation and
on the other hand it is inherent or of interest in a variety of applications.
In this paper, we propose a reversible approach to Petri nets by introducing
machinery and associated operational semantics to tackle the challenges of the
three main forms of reversibility, namely, backtracking, causal reversing and
out-of-causal-order reversing. Our proposal concerns a variation of Petri nets
where tokens are persistent and are distinguished from each other by an
identity which allows for transitions to be reversed spontaneously in or out of
causal order. Our design decisions are influenced by applications in
biochemistry but the methodology can be applied to a wide range of problems
that feature reversibility. In particular, to demonstrate the applicability of
our approach we use an example of a biochemical system and an example of a
transaction-processing system both of which naturally embed reversible
behaviour.
</summary>
    <author>
      <name>Anna Philippou</name>
    </author>
    <author>
      <name>Kyriaki Psara</name>
    </author>
    <link href="http://arxiv.org/abs/1804.04607v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1804.04607v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1805.08605v2</id>
    <updated>2018-12-18T12:42:28Z</updated>
    <published>2018-05-22T14:24:13Z</published>
    <title>Reversible effects as inverse arrows</title>
    <summary>  Reversible computing models settings in which all processes can be reversed.
Applications include low-power computing, quantum computing, and robotics. It
is unclear how to represent side-effects in this setting, because conventional
methods need not respect reversibility. We model reversible effects by adapting
Hughes' arrows to dagger arrows and inverse arrows. This captures several
fundamental reversible effects, including serialization and mutable store
computations. Whereas arrows are monoids in the category of profunctors, dagger
arrows are involutive monoids in the category of profunctors, and inverse
arrows satisfy certain additional properties. These semantics inform the design
of functional reversible programs supporting side-effects.
</summary>
    <author>
      <name>Chris Heunen</name>
    </author>
    <author>
      <name>Robin Kaarsgaard</name>
    </author>
    <author>
      <name>Martti Karvonen</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.entcs.2018.11.009</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.entcs.2018.11.009" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages; corrected Example 3.6</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Electronic Notes in Theoretical Computer Science 341:179-199, 2018</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1805.08605v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1805.08605v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1811.06961v2</id>
    <updated>2019-02-20T13:55:38Z</updated>
    <published>2018-11-16T18:35:37Z</published>
    <title>Computing the Expected Execution Time of Probabilistic Workflow Nets</title>
    <summary>  Free-Choice Workflow Petri nets, also known as Workflow Graphs, are a popular
model in Business Process Modeling.
  In this paper we introduce Timed Probabilistic Workflow Nets (TPWNs), and
give them a Markov Decision Process (MDP) semantics. Since the time needed to
execute two parallel tasks is the maximum of the times, and not their sum, the
expected time cannot be directly computed using the theory of MDPs with
rewards. In our first contribution, we overcome this obstacle with the help of
"earliest-first" schedulers, and give a single exponential-time algorithm for
computing the expected time.
  In our second contribution, we show that computing the expected time is
#P-hard, and so polynomial algorithms are very unlikely to exist. Further,
#P-hardness holds even for workflows with a very simple structure in which all
transitions times are 1 or 0, and all probabilities are 1 or 0.5.
  Our third and final contribution is an experimental investigation of the
runtime of our algorithm on a set of industrial benchmarks. Despite the
negative theoretical results, the results are very encouraging. In particular,
the expected time of every workflow in a popular benchmark suite with 642
workflow nets can be computed in milliseconds.
</summary>
    <author>
      <name>Philipp J. Meyer</name>
    </author>
    <author>
      <name>Javier Esparza</name>
    </author>
    <author>
      <name>Philip Offtermatt</name>
    </author>
    <link href="http://arxiv.org/abs/1811.06961v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1811.06961v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0602024v4</id>
    <updated>2006-03-08T15:42:17Z</updated>
    <published>2006-02-07T10:10:12Z</published>
    <title>Algorithmic correspondence and completeness in modal logic. I. The core
  algorithm SQEMA</title>
    <summary>  Modal formulae express monadic second-order properties on Kripke frames, but
in many important cases these have first-order equivalents. Computing such
equivalents is important for both logical and computational reasons. On the
other hand, canonicity of modal formulae is important, too, because it implies
frame-completeness of logics axiomatized with canonical formulae.
  Computing a first-order equivalent of a modal formula amounts to elimination
of second-order quantifiers. Two algorithms have been developed for
second-order quantifier elimination: SCAN, based on constraint resolution, and
DLS, based on a logical equivalence established by Ackermann.
  In this paper we introduce a new algorithm, SQEMA, for computing first-order
equivalents (using a modal version of Ackermann's lemma) and, moreover, for
proving canonicity of modal formulae. Unlike SCAN and DLS, it works directly on
modal formulae, thus avoiding Skolemization and the subsequent problem of
unskolemization. We present the core algorithm and illustrate it with some
examples. We then prove its correctness and the canonicity of all formulae on
which the algorithm succeeds. We show that it succeeds not only on all
Sahlqvist formulae, but also on the larger class of inductive formulae,
introduced in our earlier papers. Thus, we develop a purely algorithmic
approach to proving canonical completeness in modal logic and, in particular,
establish one of the most general completeness results in modal logic so far.
</summary>
    <author>
      <name>Willem Conradie</name>
    </author>
    <author>
      <name>Valentin Goranko</name>
    </author>
    <author>
      <name>Dimiter Vakarelov</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-2(1:5)2006</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-2(1:5)2006" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">26 pages, no figures, to appear in the Logical Methods in Computer
  Science</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 2, Issue 1 (March 7,
  2006) lmcs:2259</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0602024v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0602024v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1; I.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0611048v2</id>
    <updated>2007-01-23T13:33:21Z</updated>
    <published>2006-11-11T00:08:46Z</published>
    <title>Dense-Timed Petri Nets: Checking Zenoness, Token liveness and
  Boundedness</title>
    <summary>  We consider Dense-Timed Petri Nets (TPN), an extension of Petri nets in which
each token is equipped with a real-valued clock and where the semantics is lazy
(i.e., enabled transitions need not fire; time can pass and disable
transitions). We consider the following verification problems for TPNs. (i)
Zenoness: whether there exists a zeno-computation from a given marking, i.e.,
an infinite computation which takes only a finite amount of time. We show
decidability of zenoness for TPNs, thus solving an open problem from [Escrig et
al.]. Furthermore, the related question if there exist arbitrarily fast
computations from a given marking is also decidable. On the other hand,
universal zenoness, i.e., the question if all infinite computations from a
given marking are zeno, is undecidable. (ii) Token liveness: whether a token is
alive in a marking, i.e., whether there is a computation from the marking which
eventually consumes the token. We show decidability of the problem by reducing
it to the coverability problem, which is decidable for TPNs. (iii) Boundedness:
whether the size of the reachable markings is bounded. We consider two versions
of the problem; namely semantic boundedness where only live tokens are taken
into consideration in the markings, and syntactic boundedness where also dead
tokens are considered. We show undecidability of semantic boundedness, while we
prove that syntactic boundedness is decidable through an extension of the
Karp-Miller algorithm.
</summary>
    <author>
      <name>Parosh Abdulla</name>
    </author>
    <author>
      <name>Pritha Mahata</name>
    </author>
    <author>
      <name>Richard Mayr</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-3(1:1)2007</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-3(1:1)2007" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">61 pages, 18 figures</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 3, Issue 1 (February
  7, 2007) lmcs:2223</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0611048v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0611048v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.3.1; F.4.1; F.4.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0612120v2</id>
    <updated>2006-12-27T11:16:22Z</updated>
    <published>2006-12-22T19:45:34Z</published>
    <title>Generalizing the Paige-Tarjan Algorithm by Abstract Interpretation</title>
    <summary>  The Paige and Tarjan algorithm (PT) for computing the coarsest refinement of
a state partition which is a bisimulation on some Kripke structure is well
known. It is also well known in model checking that bisimulation is equivalent
to strong preservation of CTL, or, equivalently, of Hennessy-Milner logic.
Drawing on these observations, we analyze the basic steps of the PT algorithm
from an abstract interpretation perspective, which allows us to reason on
strong preservation in the context of generic inductively defined (temporal)
languages and of possibly non-partitioning abstract models specified by
abstract interpretation. This leads us to design a generalized Paige-Tarjan
algorithm, called GPT, for computing the minimal refinement of an abstract
interpretation-based model that strongly preserves some given language. It
turns out that PT is a straight instance of GPT on the domain of state
partitions for the case of strong preservation of Hennessy-Milner logic. We
provide a number of examples showing that GPT is of general use. We first show
how a well-known efficient algorithm for computing stuttering equivalence can
be viewed as a simple instance of GPT. We then instantiate GPT in order to
design a new efficient algorithm for computing simulation equivalence that is
competitive with the best available algorithms. Finally, we show how GPT allows
to compute new strongly preserving abstract models by providing an efficient
algorithm that computes the coarsest refinement of a given partition that
strongly preserves the language generated by the reachability operator.
</summary>
    <author>
      <name>Francesco Ranzato</name>
    </author>
    <author>
      <name>Francesco Tapparo</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Keywords: Abstract interpretation, abstract model checking, strong
  preservation, Paige-Tarjan algorithm, refinement algorithm</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0612120v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0612120v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1207.0051v1</id>
    <updated>2012-06-30T06:20:39Z</updated>
    <published>2012-06-30T06:20:39Z</published>
    <title>Computation Environments (2) Persistently Evolutionary Semantics</title>
    <summary>  In the manuscript titled "Computation environment (1)", we introduced a
notion called computation environment as an interactive model for computation
and complexity theory. In this model, Turing machines are not autonomous
entities and find their meanings through the interaction between a computist
and a universal processor, and thus due to evolution of the universal
processor, the meanings of Turing machines could change. In this manuscript, we
discuss persistently evolutionary intensions. We introduce a new semantics,
called persistently evolutionary semantics, for predicate logic that the
meaning of function and predicate symbols are not already predetermined, and
predicate and function symbols find their meaning through the interaction of
the subject with the language. In (classic) model theory, the mathematician who
studies a structure is assumed as a god who lives out of the structure, and the
study of the mathematician does not effect the structure. The meaning of
predicate and function symbols are assumed to be independent of the
mathematician who does math. The persistently evolutionary semantics could be
regarded as a start of "Interactive Model Theory" as a new paradigm in model
theory (similar to the paradigm of interactive computation). In interactive
model theory, we suppose that a mathematical structure should consist of two
parts: 1) an intelligent agent (a subject), and 2) an environment (language),
and every things should find its meaning through the interaction of these two
parts. We introduce persistently evolutionary Kripke structure for
propositional and predicate logic. Also, we propose a persistently evolutionary
Kripke semantics for the notion of computation, where the intension of a code
of a Turing machine persistently evolve. We show that in this Kripke model the
subject can never know P = NP.
</summary>
    <author>
      <name>Rasoul Ramezanian</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">16 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1207.0051v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1207.0051v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.00039v2</id>
    <updated>2015-09-03T07:35:35Z</updated>
    <published>2015-03-31T21:09:34Z</published>
    <title>Quantitative Approximation of the Probability Distribution of a Markov
  Process by Formal Abstractions</title>
    <summary>  The goal of this work is to formally abstract a Markov process evolving in
discrete time over a general state space as a finite-state Markov chain, with
the objective of precisely approximating its state probability distribution in
time, which allows for its approximate, faster computation by that of the
Markov chain. The approach is based on formal abstractions and employs an
arbitrary finite partition of the state space of the Markov process, and the
computation of average transition probabilities between partition sets. The
abstraction technique is formal, in that it comes with guarantees on the
introduced approximation that depend on the diameters of the partitions: as
such, they can be tuned at will. Further in the case of Markov processes with
unbounded state spaces, a procedure for precisely truncating the state space
within a compact set is provided, together with an error bound that depends on
the asymptotic properties of the transition kernel of the original process. The
overall abstraction algorithm, which practically hinges on piecewise constant
approximations of the density functions of the Markov process, is extended to
higher-order function approximations: these can lead to improved error bounds
and associated lower computational requirements. The approach is practically
tested to compute probabilistic invariance of the Markov process under study,
and is compared to a known alternative approach from the literature.
</summary>
    <author>
      <name>Sadegh Esmaeil Zadeh Soudjani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Oxford</arxiv:affiliation>
    </author>
    <author>
      <name>Alessandro Abate</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Oxford</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-11(3:8)2015</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-11(3:8)2015" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">29 pages, Journal of Logical Methods in Computer Science</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 11, Issue 3 (September
  4, 2015) lmcs:1584</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1504.00039v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.00039v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1702.08306v2</id>
    <updated>2017-06-29T12:09:49Z</updated>
    <published>2017-02-27T14:48:44Z</published>
    <title>On-the-Fly Computation of Bisimilarity Distances</title>
    <summary>  We propose a distance between continuous-time Markov chains (CTMCs) and study
the problem of computing it by comparing three different algorithmic
methodologies: iterative, linear program, and on-the-fly. In a work presented
at FoSSaCS'12, Chen et al. characterized the bisimilarity distance of
Desharnais et al. between discrete-time Markov chains as an optimal solution of
a linear program that can be solved by using the ellipsoid method. Inspired by
their result, we propose a novel linear program characterization to compute the
distance in the continuous-time setting. Differently from previous proposals,
ours has a number of constraints that is bounded by a polynomial in the size of
the CTMC. This, in particular, proves that the distance we propose can be
computed in polynomial time. Despite its theoretical importance, the proposed
linear program characterization turns out to be inefficient in practice.
Nevertheless, driven by the encouraging results of our previous work presented
at TACAS'13, we propose an efficient on-the-fly algorithm, which, unlike the
other mentioned solutions, computes the distances between two given states
avoiding an exhaustive exploration of the state space. This technique works by
successively refining over-approximations of the target distances using a
greedy strategy, which ensures that the state space is further explored only
when the current approximations are improved. Tests performed on a consistent
set of (pseudo)randomly generated CTMCs show that our algorithm improves, on
average, the efficiency of the corresponding iterative and linear program
methods with orders of magnitude.
</summary>
    <author>
      <name>Giorgio Bacci</name>
    </author>
    <author>
      <name>Giovanni Bacci</name>
    </author>
    <author>
      <name>Kim G. Larsen</name>
    </author>
    <author>
      <name>Radu Mardare</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.23638/LMCS-13(2:13)2017</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.23638/LMCS-13(2:13)2017" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 13, Issue 2 (June 30,
  2017) lmcs:3753</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1702.08306v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1702.08306v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="G.3; I.1.4; I.6.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0108007v1</id>
    <updated>2001-08-12T21:25:13Z</updated>
    <published>2001-08-12T21:25:13Z</published>
    <title>Abstract versus Concrete Computation on Metric Partial Algebras</title>
    <summary>  A model of computation is abstract if, when applied to any algebra, the
resulting programs for computable functions and sets on that algebra are
invariant under isomorphisms, and hence do not depend on a representation for
the algebra. Otherwise it is concrete. Intuitively, concrete models depend on
the implementation of the algebra.
  The difference is particularly striking in the case of topological partial
algebras, and notably in algebras over the reals. We investigate the
relationship between abstract and concrete models of partial metric algebras.
In the course of this investigation, interesting aspects of continuity,
extensionality and non-determinism are uncovered.
</summary>
    <author>
      <name>J. V. Tucker</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Wales, Swansea</arxiv:affiliation>
    </author>
    <author>
      <name>J. I. Zucker</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">McMaster University, Hamilton, Canada</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">75 pages, AMSTeX, 3 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0108007v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0108007v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1;F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0310064v1</id>
    <updated>2003-10-31T17:05:58Z</updated>
    <published>2003-10-31T17:05:58Z</published>
    <title>Satisfiability and computing van der Waerden numbers</title>
    <summary>  In this paper we bring together the areas of combinatorics and propositional
satisfiability. Many combinatorial theorems establish, often constructively,
the existence of positive integer functions, without actually providing their
closed algebraic form or tight lower and upper bounds. The area of Ramsey
theory is especially rich in such results. Using the problem of computing van
der Waerden numbers as an example, we show that these problems can be
represented by parameterized propositional theories in such a way that
decisions concerning their satisfiability determine the numbers (function) in
question. We show that by using general-purpose complete and local-search
techniques for testing propositional satisfiability, this approach becomes
effective -- competitive with specialized approaches. By following it, we were
able to obtain several new results pertaining to the problem of computing van
der Waerden numbers. We also note that due to their properties, especially
their structural simplicity and computational hardness, propositional theories
that arise in this research can be of use in development, testing and
benchmarking of SAT solvers.
</summary>
    <author>
      <name>Michael R. Dransfield</name>
    </author>
    <author>
      <name>Victor W. Marek</name>
    </author>
    <author>
      <name>Miroslaw Truszczynski</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of SAT-2003, LNCS, Springer Verlag</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0310064v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0310064v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.8; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0501033v1</id>
    <updated>2005-01-18T07:39:09Z</updated>
    <published>2005-01-18T07:39:09Z</published>
    <title>Playful, streamlike computation</title>
    <summary>  We offer a short tour into the interactive interpretation of sequential
programs. We emphasize streamlike computation -- that is, computation of
successive bits of information upon request. The core of the approach surveyed
here dates back to the work of Berry and the author on sequential algorithms on
concrete data structures in the late seventies, culminating in the design of
the programming language CDS, in which the semantics of programs of any type
can be explored interactively. Around one decade later, two major insights of
Cartwright and Felleisen on one hand, and of Lamarche on the other hand gave
new, decisive impulses to the study of sequentiality. Cartwright and Felleisen
observed that sequential algorithms give a direct semantics to control
operators like \\"call-cc\\" and proposed to include explicit errors both in the
syntax and in the semantics of the language PCF. Lamarche (unpublished)
connected sequential algorithms to linear logic and games. The successful
program of games semantics has spanned over the nineties until now, starting
with syntax-independent characterizations of the term model of PCF by Abramsky,
Jagadeesan, and Malacaria on one hand, and by Hyland and Ong on the other hand.
</summary>
    <author>
      <name>Pierre-Louis Curien</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Domain theory, logic and computation, Kluwer Academic Publishers
  (Ed.) (2003) 1-24</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0501033v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0501033v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0505037v6</id>
    <updated>2005-09-29T08:48:45Z</updated>
    <published>2005-05-13T15:22:57Z</published>
    <title>General Recursion via Coinductive Types</title>
    <summary>  A fertile field of research in theoretical computer science investigates the
representation of general recursive functions in intensional type theories.
Among the most successful approaches are: the use of wellfounded relations,
implementation of operational semantics, formalization of domain theory, and
inductive definition of domain predicates. Here, a different solution is
proposed: exploiting coinductive types to model infinite computations. To every
type A we associate a type of partial elements Partial(A), coinductively
generated by two constructors: the first, return(a) just returns an element
a:A; the second, step(x), adds a computation step to a recursive element
x:Partial(A). We show how this simple device is sufficient to formalize all
recursive functions between two given types. It allows the definition of fixed
points of finitary, that is, continuous, operators. We will compare this
approach to different ones from the literature. Finally, we mention that the
formalization, with appropriate structural maps, defines a strong monad.
</summary>
    <author>
      <name>Venanzio Capretta</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-1(2:1)2005</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-1(2:1)2005" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">28 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 1, Issue 2 (July 13,
  2005) lmcs:2265</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0505037v6" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0505037v6" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0510069v1</id>
    <updated>2005-10-23T16:51:02Z</updated>
    <published>2005-10-23T16:51:02Z</published>
    <title>Comparing Computational Power</title>
    <summary>  It is common practice to compare the computational power of different models
of computation. For example, the recursive functions are strictly more powerful
than the primitive recursive functions, because the latter are a proper subset
of the former (which includes Ackermann's function). Side-by-side with this
"containment" method of measuring power, it is standard to use an approach
based on "simulation". For example, one says that the (untyped) lambda calculus
is as powerful--computationally speaking--as the partial recursive functions,
because the lambda calculus can simulate all partial recursive functions by
encoding the natural numbers as Church numerals.
  The problem is that unbridled use of these two ways of comparing power allows
one to show that some computational models are strictly stronger than
themselves! We argue that a better definition is that model A is strictly
stronger than B if A can simulate B via some encoding, whereas B cannot
simulate A under any encoding. We then show that the recursive functions are
strictly stronger in this sense than the primitive recursive. We also prove
that the recursive functions, partial recursive functions, and Turing machines
are "complete", in the sense that no injective encoding can make them
equivalent to any "hypercomputational" model.
</summary>
    <author>
      <name>Udi Boker</name>
    </author>
    <author>
      <name>Nachum Dershowitz</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Logic Journal of the IGPL in 2006</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0510069v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0510069v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0711.0840v2</id>
    <updated>2008-11-18T09:29:03Z</updated>
    <published>2007-11-06T11:25:20Z</published>
    <title>A thread calculus with molecular dynamics</title>
    <summary>  We present a theory of threads, interleaving of threads, and interaction
between threads and services with features of molecular dynamics, a model of
computation that bears on computations in which dynamic data structures are
involved. Threads can interact with services of which the states consist of
structured data objects and computations take place by means of actions which
may change the structure of the data objects. The features introduced include
restriction of the scope of names used in threads to refer to data objects.
Because that feature makes it troublesome to provide a model based on
structural operational semantics and bisimulation, we construct a projective
limit model for the theory.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.ic.2010.01.004</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.ic.2010.01.004" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">47 pages; examples and results added, phrasing improved, references
  replaced</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Information and Computation, 208(7):817-844, 2010</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0711.0840v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0711.0840v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.3; D.1.5; D.3.3; F.1.1; F.1.2; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1003.5399v3</id>
    <updated>2010-10-18T11:56:43Z</updated>
    <published>2010-03-28T22:00:47Z</published>
    <title>Spatial logics with connectedness predicates</title>
    <summary>  We consider quantifier-free spatial logics, designed for qualitative spatial
representation and reasoning in AI, and extend them with the means to represent
topological connectedness of regions and restrict the number of their connected
components. We investigate the computational complexity of these logics and
show that the connectedness constraints can increase complexity from NP to
PSpace, ExpTime and, if component counting is allowed, to NExpTime.
</summary>
    <author>
      <name>Roman Kontchakov</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Birkbeck College London</arxiv:affiliation>
    </author>
    <author>
      <name>Ian Pratt-Hartmann</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, Manchester University</arxiv:affiliation>
    </author>
    <author>
      <name>Frank Wolter</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, University of Liverpool</arxiv:affiliation>
    </author>
    <author>
      <name>Michael Zakharyaschev</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Birkbeck College London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-6(3:7)2010</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-6(3:7)2010" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Some results of the paper were presented at LPAR 2008 and ECAI 2000</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 6, Issue 3 (August 18,
  2010) lmcs:1229</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1003.5399v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1003.5399v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1, I.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1006.0396v1</id>
    <updated>2010-06-02T14:30:17Z</updated>
    <published>2010-06-02T14:30:17Z</published>
    <title>The Cardinality of an Oracle in Blum-Shub-Smale Computation</title>
    <summary>  We examine the relation of BSS-reducibility on subsets of the real numbers.
The question was asked recently (and anonymously) whether it is possible for
the halting problem H in BSS-computation to be BSS-reducible to a countable
set. Intuitively, it seems that a countable set ought not to contain enough
information to decide membership in a reasonably complex (uncountable) set such
as H. We confirm this intuition, and prove a more general theorem linking the
cardinality of the oracle set to the cardinality, in a local sense, of the set
which it computes. We also mention other recent results on BSS-computation and
algebraic real numbers.
</summary>
    <author>
      <name>Wesley Calvert</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Murray State University</arxiv:affiliation>
    </author>
    <author>
      <name>Ken Kramer</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Queens College &amp; CUNY Graduate Center</arxiv:affiliation>
    </author>
    <author>
      <name>Russell Miller</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Queens College &amp; CUNY Graduate Center</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.24.10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.24.10" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 24, 2010, pp. 56-66</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1006.0396v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1006.0396v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1105.2751v1</id>
    <updated>2011-05-13T15:13:57Z</updated>
    <published>2011-05-13T15:13:57Z</published>
    <title>Computer certified efficient exact reals in Coq</title>
    <summary>  Floating point operations are fast, but require continuous effort on the part
of the user in order to ensure that the results are correct. This burden can be
shifted away from the user by providing a library of exact analysis in which
the computer handles the error estimates. We provide an implementation of the
exact real numbers in the Coq proof assistant. This improves on the earlier
Coq-implementation by O'Connor in two ways: we use dyadic rationals built from
the machine integers and we optimize computation of power series by using
approximate division. Moreover, we use type classes for clean mathematical
interfaces. This appears to be the first time that type classes are used in
heavy computation. We obtain over a 100 times speed up of the basic operations
and indications for improving the Coq system.
</summary>
    <author>
      <name>Robbert Krebbers</name>
    </author>
    <author>
      <name>Bas Spitters</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-642-22673-1_7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-642-22673-1_7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of CICM11, Springer LNAI, 2011</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of CICM11, vol 6824, Springer LNAI, 90-106, 2011</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1105.2751v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1105.2751v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; F.4.1; G.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1208.4301v1</id>
    <updated>2012-08-21T16:57:54Z</updated>
    <published>2012-08-21T16:57:54Z</published>
    <title>Proceedings Seventh ACCAT Workshop on Applied and Computational Category
  Theory</title>
    <summary>  Category Theory is a well-known powerful mathematical modeling language with
a wide area of applications in mathematics and computer science, including
especially the semantical foundations of topics in software science and
development. Categorical methods are already well established for the
semantical foundation of type theory (cartesian closed categories), data type
specification frameworks (institutions) and graph transformation (adhesive high
level replacement categories).
  It is the intention of the ACCAT Workshops on Applied and Computational
Category Theory to bring together leading researchers in these areas with those
in software science and development in order to transfer categorical concepts
and theories in both directions. The workshops aims to represent a forum for
researchers and practitioners who are interested in an exchange of ideas,
notions, and techniques for different applications of category theory.
  The seventh ACCAT workshop on Applied and Computational Category Theory 2012
was held in Tallinn, Estonia on the 1st of April 2012 as a satellite event of
ETAPS 2012. This issue contains the full version of one of the invited talks as
well as the submitted papers, which cover a wide range of applications of
category theory, from model-driven engineering over transition systems in
stochastic processes to transformations in M-adhesive categories.
</summary>
    <author>
      <name>Ulrike Golas</name>
    </author>
    <author>
      <name>Thomas Soboll</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.93</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.93" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 93, 2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1208.4301v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1208.4301v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.8213v1</id>
    <updated>2013-07-31T03:29:04Z</updated>
    <published>2013-07-31T03:29:04Z</published>
    <title>Formal Analysis of Soft Errors using Theorem Proving</title>
    <summary>  Modeling and analysis of soft errors in electronic circuits has traditionally
been done using computer simulations. Computer simulations cannot guarantee
correctness of analysis because they utilize approximate real number
representations and pseudo random numbers in the analysis and thus are not well
suited for analyzing safety-critical applications. In this paper, we present a
higher-order logic theorem proving based method for modeling and analysis of
soft errors in electronic circuits. Our developed infrastructure includes
formalized continuous random variable pairs, their Cumulative Distribution
Function (CDF) properties and independent standard uniform and Gaussian random
variables. We illustrate the usefulness of our approach by modeling and
analyzing soft errors in commonly used dynamic random access memory sense
amplifier circuits.
</summary>
    <author>
      <name>Naeem Abbasi</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">ECE Department, Concordia University, Montreal, Canada</arxiv:affiliation>
    </author>
    <author>
      <name>Osman Hasan</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">ECE Department, Concordia University, Montreal, Canada</arxiv:affiliation>
    </author>
    <author>
      <name>Sofiène Tahar</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">ECE Department, Concordia University, Montreal, Canada</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.122.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.122.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings SCSS 2012, arXiv:1307.8029, Hardware -&gt; Dynamic
  memory; Transient errors and upsets; Safety critical systems; Security and
  privacy -&gt; Logic and verification; Theory of computation -&gt; Automated
  reasoning; Computer systems organization -&gt; Reliability</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 122, 2013, pp. 75-84</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1307.8213v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.8213v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.3923v2</id>
    <updated>2013-09-10T09:44:36Z</updated>
    <published>2013-08-19T05:06:21Z</published>
    <title>Efficient Approximation of Well-Founded Justification and Well-Founded
  Domination (Corrected and Extended Version)</title>
    <summary>  Many native ASP solvers exploit unfounded sets to compute consequences of a
logic program via some form of well-founded negation, but disregard its
contrapositive, well-founded justification (WFJ), due to computational cost.
However, we demonstrate that this can hinder propagation of many relevant
conditions such as reachability. In order to perform WFJ with low computational
cost, we devise a method that approximates its consequences by computing
dominators in a flowgraph, a problem for which linear-time algorithms exist.
Furthermore, our method allows for additional unfounded set inference, called
well-founded domination (WFD). We show that the effect of WFJ and WFD can be
simulated for a important classes of logic programs that include reachability.
This paper is a corrected and extended version of a paper published at the 12th
International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR
2013). It has been adapted to exclude Theorem 10 and its consequences, but
provides all missing proofs.
</summary>
    <author>
      <name>Christian Drescher</name>
    </author>
    <author>
      <name>Toby Walsh</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12th International Conference on Logic Programming and Nonmonotonic
  Reasoning; Corrected and Extended Version</arxiv:comment>
    <link href="http://arxiv.org/abs/1308.3923v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.3923v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.2128v2</id>
    <updated>2013-09-17T19:08:35Z</updated>
    <published>2013-09-09T12:22:01Z</published>
    <title>Exploring the Boundaries of Monad Tensorability on Set</title>
    <summary>  We study a composition operation on monads, equivalently presented as large
equational theories. Specifically, we discuss the existence of tensors, which
are combinations of theories that impose mutual commutation of the operations
from the component theories. As such, they extend the sum of two theories,
which is just their unrestrained combination. Tensors of theories arise in
several contexts; in particular, in the semantics of programming languages, the
monad transformer for global state is given by a tensor. We present two main
results: we show that the tensor of two monads need not in general exist by
presenting two counterexamples, one of them involving finite powerset (i.e. the
theory of join semilattices); this solves a somewhat long-standing open
problem, and contrasts with recent results that had ruled out previously
expected counterexamples. On the other hand, we show that tensors with bounded
powerset monads do exist from countable powerset upwards.
</summary>
    <author>
      <name>Nathan Bowler</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Mathematics, Universität Hamburg</arxiv:affiliation>
    </author>
    <author>
      <name>Sergey Goncharov</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, Friedrich-Alexander-Universität Erlangen-Nürnberg</arxiv:affiliation>
    </author>
    <author>
      <name>Paul Blain Levy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">School of Computer Science, University of Birmingham</arxiv:affiliation>
    </author>
    <author>
      <name>Lutz Schröder</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, Friedrich-Alexander-Universität Erlangen-Nürnberg</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-9(3:22)2013</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-9(3:22)2013" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 9, Issue 3 (September
  18, 2013) lmcs:740</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.2128v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.2128v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1604.02603v1</id>
    <updated>2016-04-09T19:49:51Z</updated>
    <published>2016-04-09T19:49:51Z</published>
    <title>Information, Processes and Games</title>
    <summary>  We survey the prospects for an Information Dynamics which can serve as the
basis for a fundamental theory of information, incorporating qualitative and
structural as well as quantitative aspects. We motivate our discussion with
some basic conceptual puzzles: how can information increase in computation, and
what is it that we are actually computing in general? Then we survey a number
of the theories which have been developed within Computer Science, as partial
exemplifications of the kind of fundamental theory which we seek: including
Domain Theory, Dynamic Logic, and Process Algebra. We look at recent work
showing new ways of combining quantitative and qualitative theories of
information, as embodied respectively by Domain Theory and Shannon Information
Theory. Then we look at Game Semantics and Geometry of Interaction, as examples
of dynamic models of logic and computation in which information flow and
interaction are made central and explicit. We conclude by looking briefly at
some key issues for future progress.
</summary>
    <author>
      <name>Samson Abramsky</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in Philosophy of Information, vol. 8 of Handbook of the
  Philosophy of Science, edited by Dov Gabbay and John Woods. arXiv admin note:
  substantial text overlap with arXiv:quant-ph/0312044 by other authors</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Philosophy of Information, Johan van Benthem and Pieter Adriaans,
  eds., pages 483--549, 2008</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1604.02603v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1604.02603v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1210.2890v1</id>
    <updated>2012-10-09T09:23:22Z</updated>
    <published>2012-10-09T09:23:22Z</published>
    <title>Proceedings Fourth Workshop on Classical Logic and Computation</title>
    <summary>  CL&amp;C'12 was the fourth of a conference series on "Classical Logic and
Computation", held as satellite to ICALP'12 on Sunday July 8, 2012 in Warwick,
England.
  CL&amp;C intends to cover all work aiming to explore computational aspects of
classical logic and mathematics, and is focused on the exploration of the
computational content of mathematical and logical principles. The scientific
aim of this workshop is to bring together researchers from both fields and
exchange ideas. The intention of the organisers is for CL&amp;C to be an informal
workshop. Participants are encouraged to present work in progress, overviews of
more extensive work, and programmatic/position papers, as well as completed
projects. Submission of both short abstracts and of longer papers were invited.
Four submissions were accepted as full papers and are included in these
proceedings. Three more were accepted only as communications for the
conference. Paulo Oliva gave an invited talk on "Some connections between Game
Theory and Proof Theory".
</summary>
    <author>
      <name>Herman Geuvers</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Nijmegen University</arxiv:affiliation>
    </author>
    <author>
      <name>Ugo de'Liguoro</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Torino University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.97</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.97" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 97, 2012</arxiv:comment>
    <link href="http://arxiv.org/abs/1210.2890v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1210.2890v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1502.06359v3</id>
    <updated>2015-11-25T10:36:25Z</updated>
    <published>2015-02-23T09:42:56Z</published>
    <title>A Sound and Complete Axiomatization of Majority-n Logic</title>
    <summary>  Manipulating logic functions via majority operators recently drew the
attention of researchers in computer science. For example, circuit optimization
based on majority operators enables superior results as compared to traditional
logic systems. Also, the Boolean satisfiability problem finds new solving
approaches when described in terms of majority decisions. To support computer
logic applications based on majority a sound and complete set of axioms is
required. Most of the recent advances in majority logic deal only with ternary
majority (MAJ- 3) operators because the axiomatization with solely MAJ-3 and
complementation operators is well understood. However, it is of interest
extending such axiomatization to n-ary majority operators (MAJ-n) from both the
theoretical and practical perspective. In this work, we address this issue by
introducing a sound and complete axiomatization of MAJ-n logic. Our
axiomatization naturally includes existing majority logic systems. Based on
this general set of axioms, computer applications can now fully exploit the
expressive power of majority logic.
</summary>
    <author>
      <name>Luca Amaru</name>
    </author>
    <author>
      <name>Pierre-Emmanuel Gaillardon</name>
    </author>
    <author>
      <name>Anupam Chattopadhyay</name>
    </author>
    <author>
      <name>Giovanni De Micheli</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1109/TC.2015.2506566</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1109/TC.2015.2506566" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted by the IEEE Transactions on Computers</arxiv:comment>
    <link href="http://arxiv.org/abs/1502.06359v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1502.06359v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1404.7092v1</id>
    <updated>2014-04-28T18:54:28Z</updated>
    <published>2014-04-28T18:54:28Z</published>
    <title>Robustness against Power is PSPACE-complete</title>
    <summary>  Power is a RISC architecture developed by IBM, Freescale, and several other
companies and implemented in a series of POWER processors. The architecture
features a relaxed memory model providing very weak guarantees with respect to
the ordering and atomicity of memory accesses.
  Due to these weaknesses, some programs that are correct under sequential
consistency (SC) show undesirable effects when run under Power. We call these
programs not robust against the Power memory model. Formally, a program is
robust if every computation under Power has the same data and control
dependencies as some SC computation.
  Our contribution is a decision procedure for robustness of concurrent
programs against the Power memory model. It is based on three ideas. First, we
reformulate robustness in terms of the acyclicity of a happens-before relation.
Second, we prove that among the computations with cyclic happens-before
relation there is one in a certain normal form. Finally, we reduce the
existence of such a normal-form computation to a language emptiness problem.
Altogether, this yields a PSPACE algorithm for checking robustness against
Power. We complement it by a matching lower bound to show PSPACE-completeness.
</summary>
    <author>
      <name>Egor Derevenetc</name>
    </author>
    <author>
      <name>Roland Meyer</name>
    </author>
    <link href="http://arxiv.org/abs/1404.7092v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1404.7092v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68Q60" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; D.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.04126v1</id>
    <updated>2016-06-13T20:31:08Z</updated>
    <published>2016-06-13T20:31:08Z</published>
    <title>Dividing by zero - how bad is it, really?</title>
    <summary>  In computable analysis testing a real number for being zero is a fundamental
example of a non-computable task. This causes problems for division: We cannot
ensure that the number we want to divide by is not zero. In many cases, any
real number would be an acceptable outcome if the divisor is zero - but even
this cannot be done in a computable way.
  In this note we investigate the strength of the computational problem "Robust
division": Given a pair of real numbers, the first not greater than the other,
output their quotient if well-defined and any real number else. The formal
framework is provided by Weihrauch reducibility. One particular result is that
having later calls to the problem depending on the outcomes of earlier ones is
strictly more powerful than performing all calls concurrently. However, having
a nesting depths of two already provides the full power. This solves an open
problem raised at a recent Dagstuhl meeting on Weihrauch reducibility.
  As application for "Robust division", we show that it suffices to execute
Gaussian elimination.
</summary>
    <author>
      <name>Takayuki Kihara</name>
    </author>
    <author>
      <name>Arno Pauly</name>
    </author>
    <link href="http://arxiv.org/abs/1606.04126v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.04126v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03F60, 03D80, 65F99" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.2.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1311.2960v1</id>
    <updated>2013-11-11T03:34:18Z</updated>
    <published>2013-11-11T03:34:18Z</published>
    <title>An Axiomatization for Quantum Processes to Unifying Quantum and
  Classical Computing</title>
    <summary>  We establish an axiomatization for quantum processes, which is a quantum
generalization of process algebra ACP (Algebra of Communicating Processes). We
use the framework of a quantum process configuration $langle p,
varrhorangle$, but we treat it as two relative independent part: the
structural part $p$ and the quantum part $varrho$, because the establishment
of a sound and complete theory is dependent on the structural properties of the
structural part $p$. We let the quantum part $varrho$ be the outcomes of
execution of $p$ to examine and observe the function of the basic theory of
quantum mechanics. We establish not only a strong bisimularity for quantum
processes, but also a weak bisimularity to model the silent step and abstract
internal computations in quantum processes. The relationship between quantum
bisimularity and classical bisimularity is established, which makes an
axiomatization of quantum processes possible. An axiomatization for quantum
processes called qACP is designed, which involves not only quantum information,
but also classical information and unifies quantum computing and classical
computing. qACP can be used easily and widely for verification of most quantum
communication protocols.
</summary>
    <author>
      <name>Yong Wang</name>
    </author>
    <link href="http://arxiv.org/abs/1311.2960v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1311.2960v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.0266v1</id>
    <updated>2014-08-31T21:15:40Z</updated>
    <published>2014-08-31T21:15:40Z</published>
    <title>Virtual Evidence: A Constructive Semantics for Classical Logics</title>
    <summary>  This article presents a computational semantics for classical logic using
constructive type theory. Such semantics seems impossible because classical
logic allows the Law of Excluded Middle (LEM), not accepted in constructive
logic since it does not have computational meaning. However, the apparently
oracular powers expressed in the LEM, that for any proposition P either it or
its negation, not P, is true can also be explained in terms of constructive
evidence that does not refer to "oracles for truth." Types with virtual
evidence and the constructive impossibility of negative evidence provide
sufficient semantic grounds for classical truth and have a simple computational
meaning. This idea is formalized using refinement types, a concept of
constructive type theory used since 1984 and explained here. A new axiom
creating virtual evidence fully retains the constructive meaning of the logical
operators in classical contexts.
  Key Words: classical logic, constructive logic, intuitionistic logic,
propositions-as-types, constructive type theory, refinement types, double
negation translation, computational content, virtual evidence
</summary>
    <author>
      <name>Robert L. Constable</name>
    </author>
    <link href="http://arxiv.org/abs/1409.0266v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.0266v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.2593v1</id>
    <updated>2014-09-09T04:26:39Z</updated>
    <published>2014-09-09T04:26:39Z</published>
    <title>Proceedings Fifth International Workshop on Classical Logic and
  Computation</title>
    <summary>  Classical Logic and Computation (CL&amp;C) 2014 is the fifth edition of this
workshop series. The workshop series intends to cover all work aiming to
explore computational aspects of classical logic and mathematics. Its focus is
on the exploration of the computational content of mathematical and logical
principles, aiming to bring together researchers from both fields and exchange
ideas. In this fifth edition we received 18 submissions of both short and full
papers. Fourteen (14) of these were selected to present at the meeting in
Vienna, and six (6) full papers were accepted to appear at this ETPCS special
volume. Topics covered by this years submissions included: translations of
classical to intuitionistic proofs, witness extraction from classical proofs,
confluence properties for classical systems, linear logic, constructive
semantics for classical logic (game semantics, realizability), and the study of
calculi based on classical logic (lambda-mu-calculus, continuation calculus).
</summary>
    <author>
      <name>Paulo Oliva</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Queen Mary University of London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.164</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.164" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 164, 2014</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1409.2593v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.2593v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1411.7140v1</id>
    <updated>2014-11-26T08:38:13Z</updated>
    <published>2014-11-26T08:38:13Z</published>
    <title>Program certification with computational effects</title>
    <summary>  Dynamic evaluation is a paradigm in computer algebra which was introduced for
computing with algebraic numbers. In linear algebra, for instance, dynamic
evaluation can be used to apply programs which have been written for matrices
with coefficients modulo some prime number to matrices with coefficients modulo
some composite number. A way to implement dynamic evaluation in modern
computing languages is to use the exceptions mechanism provided by the
language. In this paper, we pesent a proof system for exceptions which involves
both raising and handling, by extending Moggi's approach based on monads.
Moreover, the core part of this proof system is dual to a proof system for the
state effect in imperative languages, which relies on the categorical notion of
comonad. Both proof systems are implemented in the Coq proof assistant, and
they are combined in order to deal with both effects at the same time.
</summary>
    <author>
      <name>Jean-Guillaume Dumas</name>
    </author>
    <author>
      <name>Dominique Duval</name>
    </author>
    <author>
      <name>Burak Ekici</name>
    </author>
    <author>
      <name>Damien Pous</name>
    </author>
    <link href="http://arxiv.org/abs/1411.7140v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1411.7140v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1505.06617v1</id>
    <updated>2015-05-25T13:13:25Z</updated>
    <published>2015-05-25T13:13:25Z</published>
    <title>Efficient computation of generalized Ising polynomials on graphs with
  fixed clique-width</title>
    <summary>  Graph polynomials which are definable in Monadic Second Order Logic (MSOL) on
the vocabulary of graphs are Fixed-Parameter Tractable (FPT) with respect to
clique-width. In contrast, graph polynomials which are definable in MSOL on the
vocabulary of hypergraphs are fixed-parameter tractable with respect to
tree-width, but not necessarily with respect to clique width. No algorithmic
meta-theorem is known for the computation of graph polynomials definable in
MSOL on the vocabulary of hypergraphs with respect to clique-width. We define
an infinite class of such graph polynomials extending the class of graph
polynomials definable in MSOL on the vocabulary of graphs and prove that they
are Fixed-Parameter Polynomial Time (FPPT) computable, i.e. that they can be
computed in time $O(n^{f(k)})$, where $n$ is the number of vertices and $k$ is
the clique-width.
</summary>
    <author>
      <name>Tomer Kotek</name>
    </author>
    <author>
      <name>Johann A. Makowsky</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 1 figure</arxiv:comment>
    <link href="http://arxiv.org/abs/1505.06617v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1505.06617v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="05C31" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1; F.2.2; G.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1506.03943v2</id>
    <updated>2015-10-23T00:14:23Z</updated>
    <published>2015-06-12T09:04:56Z</published>
    <title>The computability path ordering</title>
    <summary>  This paper aims at carrying out termination proofs for simply typed
higher-order calculi automatically by using ordering comparisons. To this end,
we introduce the computability path ordering (CPO), a recursive relation on
terms obtained by lifting a precedence on function symbols. A first version,
core CPO, is essentially obtained from the higher-order recursive path ordering
(HORPO) by eliminating type checks from some recursive calls and by
incorporating the treatment of bound variables as in the com-putability
closure. The well-foundedness proof shows that core CPO captures the essence of
computability arguments 'a la Tait and Girard, therefore explaining its name.
We further show that no further type check can be eliminated from its recursive
calls without loosing well-foundedness, but for one for which we found no
counterexample yet. Two extensions of core CPO are then introduced which allow
one to consider: the first, higher-order inductive types; the second, a
precedence in which some function symbols are smaller than application and
abstraction.
</summary>
    <author>
      <name>Frédéric Blanqui</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA</arxiv:affiliation>
    </author>
    <author>
      <name>Jean-Pierre Jouannaud</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Ecole Polytechnique, Université Paris-Sud, Tsinghua University</arxiv:affiliation>
    </author>
    <author>
      <name>Albert Rubio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Technical University of Catalonia</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-11(4:3)2015</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-11(4:3)2015" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 11, Issue 4 (October
  26, 2015) lmcs:1604</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1506.03943v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1506.03943v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1611.07178v1</id>
    <updated>2016-11-22T07:41:53Z</updated>
    <published>2016-11-22T07:41:53Z</published>
    <title>Proceedings Fifth Workshop on Synthesis</title>
    <summary>  The SYNT workshop aims to bring together researchers interested in the broad
area of synthesis of computing systems. The goal is to foster the development
of frontier techniques in automating the development of computing system.
Contributions of interest include algorithms, complexity and decidability
analysis, as well as reproducible heuristics, implemented tools, and
experimental evaluation. Application domains include software, hardware,
embedded, and cyberphysical systems. Computation models include functional,
reactive, hybrid and timed systems. Identifying, formalizing, and evaluating
synthesis in particular application domains is encouraged.
  The fifth iteration of the workshop took place in Toronto, Canada. It was
co-located with the 28th International Conference on Computer Aided
Verification. The workshop included twelve contributed talks and two invited
talks. In addition, it featured a special session about the Syntax-Guided
Synthesis Competition (SyGuS) and the SyntComp Synthesis competition.
</summary>
    <author>
      <name>Ruzica Piskac</name>
    </author>
    <author>
      <name>Rayna Dimitrova</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.229</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.229" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 229, 2016</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1611.07178v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1611.07178v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1802.08064v1</id>
    <updated>2018-02-22T14:40:47Z</updated>
    <published>2018-02-22T14:40:47Z</published>
    <title>Computing the concurrency threshold of sound free-choice workflow nets</title>
    <summary>  Workflow graphs extend classical flow charts with concurrent fork and join
nodes. They constitute the core of business processing languages such as BPMN
or UML Activity Diagrams. The activities of a workflow graph are executed by
humans or machines, generically called resources. If concurrent activities
cannot be executed in parallel by lack of resources, the time needed to execute
the workflow increases. We study the problem of computing the minimal number of
resources necessary to fully exploit the concurrency of a given workflow, and
execute it as fast as possible (i.e., as fast as with unlimited resources).
  We model this problem using free-choice Petri nets, which are known to be
equivalent to workflow graphs. We analyze the computational complexity of two
versions of the problem: computing the resource and concurrency thresholds. We
use the results to design an algorithm to approximate the concurrency
threshold, and evaluate it on a benchmark suite of 642 industrial examples. We
show that it performs very well in practice: It always provides the exact
value, and never takes more than 30 milliseconds for any workflow, even for
those with a huge number of reachable markings.
</summary>
    <author>
      <name>Philipp J. Meyer</name>
    </author>
    <author>
      <name>Javier Esparza</name>
    </author>
    <author>
      <name>Hagen Völzer</name>
    </author>
    <link href="http://arxiv.org/abs/1802.08064v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1802.08064v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1804.05001v1</id>
    <updated>2018-04-13T15:45:56Z</updated>
    <published>2018-04-13T15:45:56Z</published>
    <title>Sound Value Iteration</title>
    <summary>  Computing reachability probabilities is at the heart of probabilistic model
checking. All model checkers compute these probabilities in an iterative
fashion using value iteration. This technique approximates a fixed point from
below by determining reachability probabilities for an increasing number of
steps. To avoid results that are significantly off, variants have recently been
proposed that converge from both below and above. These procedures require
starting values for both sides. We present an alternative that does not require
the a priori computation of starting vectors and that converges faster on many
benchmarks. The crux of our technique is to give tight and safe bounds - whose
computation is cheap - on the reachability probabilities. Lifting this
technique to expected rewards is trivial for both Markov chains and MDPs.
Experimental results on a large set of benchmarks show its scalability and
efficiency.
</summary>
    <author>
      <name>Tim Quatmann</name>
    </author>
    <author>
      <name>Joost-Pieter Katoen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Technical Report</arxiv:comment>
    <link href="http://arxiv.org/abs/1804.05001v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1804.05001v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1804.08443v1</id>
    <updated>2018-04-23T14:00:41Z</updated>
    <published>2018-04-23T14:00:41Z</published>
    <title>Top-down and Bottom-up Evaluation Procedurally Integrated</title>
    <summary>  This paper describes how XSB combines top-down and bottom-up computation
through the mechanisms of variant tabling and subsumptive tabling with
abstraction, respectively.
  It is well known that top-down evaluation of logical rules in Prolog has a
procedural interpretation as recursive procedure invocation (Kowalski 1986).
Tabling adds the intuition of short-circuiting redundant computations (Warren
1992) .This paper shows how to introduce into tabled logic program evaluation a
bottom-up component, whose procedural intuition is the initialization of a data
structure, in which a relation is initially computed and filled, on first
demand, and then used throughout the remainder of a larger computation for
efficient lookup. This allows many Prolog programs to be expressed fully
declaratively, programs which formerly required procedural features, such as
assert, to be made efficient.
  This paper is under consideration for acceptance in "Theory and Practice of
Logic Programming (TPLP)".
</summary>
    <author>
      <name>David S. Warren</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 34nd International Conference on Logic
  Programming (ICLP 2018), Oxford, UK, July 14 to July 17, 2018, 16 pages,
  LaTeX, 1 PDF figure</arxiv:comment>
    <link href="http://arxiv.org/abs/1804.08443v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1804.08443v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1804.09098v1</id>
    <updated>2018-04-24T15:29:10Z</updated>
    <published>2018-04-24T15:29:10Z</published>
    <title>Guarded Computational Type Theory</title>
    <summary>  Nakano's later modality can be used to specify and define recursive functions
which are causal or synchronous; in concert with a notion of clock variable, it
is possible to also capture the broader class of productive (co)programs. Until
now, it has been difficult to combine these constructs with dependent types in
a way that preserves the operational meaning of type theory and admits a
hierarchy of universes. We present an operational account of guarded dependent
type theory with clocks called Guarded Computational Type Theory, featuring a
novel clock intersection connective that enjoys the clock irrelevance
principle, as well as a predicative hierarchy of universes which does not
require any indexing in clock contexts. Guarded Computational Type Theory is
simultaneously a programming language with a rich specification logic, as well
as a computational metalanguage that can be used to develop semantics of other
languages and logics.
</summary>
    <author>
      <name>Jonathan Sterling</name>
    </author>
    <author>
      <name>Robert Harper</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in LICS 2018</arxiv:comment>
    <link href="http://arxiv.org/abs/1804.09098v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1804.09098v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.04949v1</id>
    <updated>2018-08-15T02:26:40Z</updated>
    <published>2018-08-15T02:26:40Z</published>
    <title>A theory of finite structures</title>
    <summary>  We develop a novel formal theory of finite structures, based on a view of
finite structures as a fundamental artifact of computing and programming,
forming a common platform for computing both within particular finite
structures, and in the aggregate for computing over infinite data-types
construed as families of finite structures. A "finite structure" is here a
finite collection of finite partial-functions, over a common universe of atoms.
The theory is second-order, as it uses quantification over finite functions.
  Our formal theory FS uses a small number of fundamental axiom-schemas, with
finiteness enforced by a schema of induction on finite partial-functions. We
show that computability is definable in the theory by existential formulas,
generalizing Kleene's Theorem on the Sigma-1 definability of RE sets, and use
that result to prove that FS is mutually interpretable with Peano Arithmetic.
</summary>
    <author>
      <name>Daniel Leivant</name>
    </author>
    <link href="http://arxiv.org/abs/1808.04949v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.04949v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03D75" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1902.07684v2</id>
    <updated>2019-07-17T18:44:13Z</updated>
    <published>2019-02-20T18:07:09Z</published>
    <title>An Adequate While-Language for Hybrid Computation</title>
    <summary>  Hybrid computation combines discrete and continuous dynamics in the form of
an entangled mixture inherently present both in various natural phenomena, and
in applications ranging from control theory to microbiology. The emergent
behaviours bear signs of both computational and physical processes, and thus
present difficulties not only for analysis, but also for describing them
adequately in a structural, well-founded way. Here, we introduce a language for
hybrid computation, inspired by the fine-grain call-by-value paradigm, and
equip it with a denotational and computationally adequate denotational
semantics. Our denotational semantics crucially relies on a hybrid monad
supporting an (Elgot) iteration operator, we developed elsewhere. As an
intermediate step we introduce a more lightweight duration semantics furnished
with analogous results and drawing on a new duration monad that we introduce as
a lightweight counterpart to the hybrid monad.
</summary>
    <author>
      <name>Sergey Goncharov</name>
    </author>
    <author>
      <name>Renato Neves</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted at PPDP'19</arxiv:comment>
    <link href="http://arxiv.org/abs/1902.07684v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1902.07684v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1911.00407v1</id>
    <updated>2019-10-29T10:23:01Z</updated>
    <published>2019-10-29T10:23:01Z</published>
    <title>A Graph-Based Tool to Embed the π-Calculus into a Computational DPO
  Framework</title>
    <summary>  Graph transformation approaches have been successfully used to analyse and
design chemical and biological systems. Here we build on top of a DPO
framework, in which molecules are modelled as typed attributed graphs and
chemical reactions are modelled as graph transformations. Edges and vertexes
can be labelled with first-order terms, which can be used to encode, e.g.,
steric information of molecules. While targeted to chemical settings, the
computational framework is intended to be very generic and applicable to the
exploration of arbitrary spaces derived via iterative application of rewrite
rules, such as process calculi like Milner's {pi}-calculus. To illustrate the
generality of the framework, we introduce EpiM: a tool for computing execution
spaces of {pi}-calculus processes. EpiM encodes {pi}-calculus processes as
typed attributed graphs and then exploits the existing DPO framework to compute
their dynamics in the form of graphs where nodes are {pi}-calculus processes
and edges are reduction steps. EpiM takes advantage of the graph-based
representation and facilities offered by the framework, like efficient
isomorphism checking to prune the space without resorting to explicit
structural equivalences. EpiM is available as an online Python-based tool.
</summary>
    <author>
      <name>Jakob Lykke Andersen</name>
    </author>
    <author>
      <name>Marc Hellmuth</name>
    </author>
    <author>
      <name>Daniel Merkle</name>
    </author>
    <author>
      <name>Nikolai Nøjgaard</name>
    </author>
    <author>
      <name>Marco Peressotti</name>
    </author>
    <link href="http://arxiv.org/abs/1911.00407v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1911.00407v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2002.12554v1</id>
    <updated>2020-02-28T05:24:00Z</updated>
    <published>2020-02-28T05:24:00Z</published>
    <title>Tools in Term Rewriting for Education</title>
    <summary>  Term rewriting is a Turing complete model of computation. When taught to
students of computer science, key properties of computation as well as
techniques to analyze programs on an abstract level are conveyed. This paper
gives a swift introduction to term rewriting and presents several automatic
tools to analyze term rewrite systems which were developed by the Computational
Logic Group at the University of Innsbruck. These include the termination tool
TTT2, the confluence prover CSI, the completion tools mkbTT and KBCV, the
complexity tool TcT, the strategy tool AutoStrat, as well as FORT, an
implementation of the decision procedure for the first-order theory for a
decidable class of rewrite systems. Besides its applications in research, this
software pool has also proved invaluable for teaching, e.g., in multiple
editions of the International Summer School on Rewriting.
</summary>
    <author>
      <name>Sarah Winkler</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Università di Verona, Italy</arxiv:affiliation>
    </author>
    <author>
      <name>Aart Middeldorp</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Innsbruck, Austria</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.313.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.313.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ThEdu'19, arXiv:2002.11895</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 313, 2020, pp. 54-72</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2002.12554v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2002.12554v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1; K.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/9301102v1</id>
    <updated>2000-10-31T00:00:00Z</updated>
    <published>2000-10-31T00:00:00Z</published>
    <title>Constructing Recursion Operators in Intuitionistic Type Theory</title>
    <summary>  Martin-L\\"of's Intuitionistic Theory of Types is becoming popular for formal
reasoning about computer programs. To handle recursion schemes other than
primitive recursion, a theory of well-founded relations is presented. Using
primitive recursion over higher types, induction and recursion are formally
derived for a large class of well-founded relations. Included are &lt; on natural
numbers, and relations formed by inverse images, addition, multiplication, and
exponentiation of other relations. The constructions are given in full detail
to allow their use in theorem provers for Type Theory, such as Nuprl. The
theory is compared with work in the field of ordinal recursion over higher
types.
</summary>
    <author>
      <name>Lawrence C. Paulson</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Symbolic Computation 2 (1986), 325-355</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/9301102v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/9301102v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/9301107v1</id>
    <updated>2000-10-31T00:00:00Z</updated>
    <published>2000-10-31T00:00:00Z</published>
    <title>A Formulation of the Simple Theory of Types (for Isabelle)</title>
    <summary>  Simple type theory is formulated for use with the generic theorem prover
Isabelle. This requires explicit type inference rules. There are function,
product, and subset types, which may be empty. Descriptions (the eta-operator)
introduce the Axiom of Choice. Higher-order logic is obtained through
reflection between formulae and terms of type bool. Recursive types and
functions can be formally constructed. Isabelle proof procedures are described.
The logic appears suitable for general mathematics as well as computational
problems.
</summary>
    <author>
      <name>Lawrence C. Paulson</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">published in P. Martin-L\\"of &amp; G. Mints (editors), COLOG-88:
  International Conf. in Computer Logic (Springer LNCS 417, 1990), 246-274</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/9301107v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/9301107v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0501039v1</id>
    <updated>2005-01-19T15:00:46Z</updated>
    <published>2005-01-19T15:00:46Z</published>
    <title>Introduction to linear logic and ludics, part II</title>
    <summary>  This paper is the second part of an introduction to linear logic and ludics,
both due to Girard. It is devoted to proof nets, in the limited, yet central,
framework of multiplicative linear logic and to ludics, which has been recently
developped in an aim of further unveiling the fundamental interactive nature of
computation and logic. We hope to offer a few computer science insights into
this new theory.
</summary>
    <author>
      <name>Pierre-Louis Curien</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Advances in Mathematics (China) 35, 1 (2006) 1-44</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0501039v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0501039v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0511006v2</id>
    <updated>2008-03-04T06:15:56Z</updated>
    <published>2005-11-02T01:45:56Z</published>
    <title>Logical Relations for Monadic Types</title>
    <summary>  Logical relations and their generalizations are a fundamental tool in proving
properties of lambda-calculi, e.g., yielding sound principles for observational
equivalence. We propose a natural notion of logical relations able to deal with
the monadic types of Moggi's computational lambda-calculus. The treatment is
categorical, and is based on notions of subsconing, mono factorization systems,
and monad morphisms. Our approach has a number of interesting applications,
including cases for lambda-calculi with non-determinism (where being in logical
relation means being bisimilar), dynamic name creation, and probabilistic
systems.
</summary>
    <author>
      <name>Jean Goubault-Larrecq</name>
    </author>
    <author>
      <name>Slawomir Lasota</name>
    </author>
    <author>
      <name>David Nowak</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S0960129508007172</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S0960129508007172" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">83 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Mathematical Structures in Computer Science, 18(6):1169-1217,
  December 2008</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0511006v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0511006v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0612069v2</id>
    <updated>2007-01-25T16:13:48Z</updated>
    <published>2006-12-13T09:59:56Z</published>
    <title>Cores of Countably Categorical Structures</title>
    <summary>  A relational structure is a core, if all its endomorphisms are embeddings.
This notion is important for computational complexity classification of
constraint satisfaction problems. It is a fundamental fact that every finite
structure has a core, i.e., has an endomorphism such that the structure induced
by its image is a core; moreover, the core is unique up to isomorphism. Weprove
that every omega -categorical structure has a core. Moreover, every
omega-categorical structure is homomorphically equivalent to a model-complete
core, which is unique up to isomorphism, and which is finite or omega
-categorical. We discuss consequences for constraint satisfaction with omega
-categorical templates.
</summary>
    <author>
      <name>Manuel Bodirsky</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-3(1:2)2007</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-3(1:2)2007" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 3, Issue 1 (January
  25, 2007) lmcs:2224</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0612069v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0612069v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0711.0194v2</id>
    <updated>2007-11-12T09:28:32Z</updated>
    <published>2007-11-01T19:25:13Z</published>
    <title>Coinductive Proof Principles for Stochastic Processes</title>
    <summary>  We give an explicit coinduction principle for recursively-defined stochastic
processes. The principle applies to any closed property, not just equality, and
works even when solutions are not unique. The rule encapsulates low-level
analytic arguments, allowing reasoning about such processes at a higher
algebraic level. We illustrate the use of the rule in deriving properties of a
simple coin-flip process.
</summary>
    <author>
      <name>Dexter Kozen</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-3(4:8)2007</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-3(4:8)2007" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">16 pages, 2 figures. Preliminary version appeared in: Rajeev Alur,
  ed., Proc. 21st Symp. Logic in Computer Science (LICS'06), pages 359-366.
  IEEE, August 2006</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 3, Issue 4 (November
  12, 2007) lmcs:1098</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0711.0194v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0711.0194v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1; F.3.1; I.1.3; I.2.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0808.3928v2</id>
    <updated>2008-09-25T22:32:15Z</updated>
    <published>2008-08-28T15:31:31Z</published>
    <title>On the strength of proof-irrelevant type theories</title>
    <summary>  We present a type theory with some proof-irrelevance built into the
conversion rule. We argue that this feature is useful when type theory is used
as the logical formalism underlying a theorem prover. We also show a close
relation with the subset types of the theory of PVS. We show that in these
theories, because of the additional extentionality, the axiom of choice implies
the decidability of equality, that is, almost classical logic. Finally we
describe a simple set-theoretic semantics.
</summary>
    <author>
      <name>Benjamin Werner</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-4(3:13)2008</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-4(3:13)2008" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">20 pages, Logical Methods in Computer Science, Long version of IJCAR
  2006 paper</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 4, Issue 3 (September
  26, 2008) lmcs:1142</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0808.3928v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0808.3928v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0905.4612v2</id>
    <updated>2009-05-29T14:14:17Z</updated>
    <published>2009-05-28T11:13:58Z</published>
    <title>Straight-line instruction sequence completeness for total calculation on
  cancellation meadows</title>
    <summary>  A combination of program algebra with the theory of meadows is designed
leading to a theory of computation in algebraic structures which use in
addition to a zero test and copying instructions the instruction set $\\{x
Leftarrow 0, x Leftarrow 1, xLeftarrow -x, xLeftarrow x^{-1}, xLeftarrow
x+y, xLeftarrow xcdot y\\}$. It is proven that total functions on cancellation
meadows can be computed by straight-line programs using at most 5 auxiliary
variables. A similar result is obtained for signed meadows.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <author>
      <name>Inge Bethke</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">24 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0905.4612v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0905.4612v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1006.5102v1</id>
    <updated>2010-06-26T03:03:45Z</updated>
    <published>2010-06-26T03:03:45Z</published>
    <title>An expectation transformer approach to predicate abstraction and data
  independence for probabilistic programs</title>
    <summary>  In this paper we revisit the well-known technique of predicate abstraction to
characterise performance attributes of system models incorporating probability.
We recast the theory using expectation transformers, and identify transformer
properties which correspond to abstractions that yield nevertheless exact bound
on the performance of infinite state probabilistic systems. In addition, we
extend the developed technique to the special case of "data independent"
programs incorporating probability. Finally, we demonstrate the subtleness of
the extended technique by using the PRISM model checking tool to analyse an
infinite state protocol, obtaining exact bounds on its performance.
</summary>
    <author>
      <name>Ukachukwu Ndukwu</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Deptartment of Computing, Macquarie University, Australia.</arxiv:affiliation>
    </author>
    <author>
      <name>Annabelle McIver</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Deptartment of Computing, Macquarie University, Australia.</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.28.9</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.28.9" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 28, 2010, pp. 129-143</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1006.5102v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1006.5102v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1008.1809v1</id>
    <updated>2010-08-10T21:29:13Z</updated>
    <published>2010-08-10T21:29:13Z</published>
    <title>Symmetry-breaking Answer Set Solving</title>
    <summary>  In the context of Answer Set Programming, this paper investigates
symmetry-breaking to eliminate symmetric parts of the search space and,
thereby, simplify the solution process. We propose a reduction of disjunctive
logic programs to a coloured digraph such that permutational symmetries can be
constructed from graph automorphisms. Symmetries are then broken by introducing
symmetry-breaking constraints. For this purpose, we formulate a preprocessor
that integrates a graph automorphism system. Experiments demonstrate its
computational impact.
</summary>
    <author>
      <name>Christian Drescher</name>
    </author>
    <author>
      <name>Oana Tifrea</name>
    </author>
    <author>
      <name>Toby Walsh</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of ICLP'10 Workshop on Answer Set Programming and Other
  Computing Paradigm</arxiv:comment>
    <link href="http://arxiv.org/abs/1008.1809v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1008.1809v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1009.2893v2</id>
    <updated>2010-09-20T08:22:57Z</updated>
    <published>2010-09-15T10:30:50Z</published>
    <title>On Second-Order Monadic Monoidal and Groupoidal Quantifiers</title>
    <summary>  We study logics defined in terms of second-order monadic monoidal and
groupoidal quantifiers. These are generalized quantifiers defined by monoid and
groupoid word-problems, equivalently, by regular and context-free languages. We
give a computational classification of the expressive power of these logics
over strings with varying built-in predicates. In particular, we show that
ATIME(n) can be logically characterized in terms of second-order monadic
monoidal quantifiers.
</summary>
    <author>
      <name>Juha Kontinen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Helsinki, Finland</arxiv:affiliation>
    </author>
    <author>
      <name>Heribert Vollmer</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Hannover, Germany</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-6(3:25)2010</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-6(3:25)2010" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 6, Issue 3 (September
  20, 2010) lmcs:1006</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1009.2893v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1009.2893v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1, F.4.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1011.6438v1</id>
    <updated>2010-11-30T01:39:19Z</updated>
    <published>2010-11-30T01:39:19Z</published>
    <title>Process Behaviour: Formulae vs. Tests (Extended Abstract)</title>
    <summary>  Process behaviour is often defined either in terms of the tests they satisfy,
or in terms of the logical properties they enjoy. Here we compare these two
approaches, using extensional testing in the style of DeNicola, Hennessy, and a
recursive version of the property logic HML. We first characterise subsets of
this property logic which can be captured by tests. Then we show that those
subsets of the property logic capture precisely the power of tests.
</summary>
    <author>
      <name>Andrea Cerone</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, Trinity College Dublin</arxiv:affiliation>
    </author>
    <author>
      <name>Matthew Hennessy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, Trinity College Dublin</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.41.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.41.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings EXPRESS'10, arXiv:1011.6012</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 41, 2010, pp. 31-45</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1011.6438v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1011.6438v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.0112v4</id>
    <updated>2013-04-01T10:38:19Z</updated>
    <published>2010-12-30T16:47:56Z</published>
    <title>The degree structure of Weihrauch-reducibility</title>
    <summary>  We answer a question by Vasco Brattka and Guido Gherardi by proving that the
Weihrauch-lattice is not a Brouwer algebra. The computable Weihrauch-lattice is
also not a Heyting algebra, but the continuous Weihrauch-lattice is. We further
investigate the existence of infinite infima and suprema, as well as embeddings
of the Medvedev-degrees into the Weihrauch-degrees.
</summary>
    <author>
      <name>Kojiro Higuchi</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Tohoku University</arxiv:affiliation>
    </author>
    <author>
      <name>Arno Pauly</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cambridge</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-9(2:2)2013</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-9(2:2)2013" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 9, Issue 2 (April 2,
  2013) lmcs:1124</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1101.0112v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.0112v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.2162v3</id>
    <updated>2012-04-23T18:37:01Z</updated>
    <published>2011-01-11T16:54:22Z</published>
    <title>From coinductive proofs to exact real arithmetic: theory and
  applications</title>
    <summary>  Based on a new coinductive characterization of continuous functions we
extract certified programs for exact real number computation from constructive
proofs. The extracted programs construct and combine exact real number
algorithms with respect to the binary signed digit representation of real
numbers. The data type corresponding to the coinductive definition of
continuous functions consists of finitely branching non-wellfounded trees
describing when the algorithm writes and reads digits. We discuss several
examples including the extraction of programs for polynomials up to degree two
and the definite integral of continuous maps.
</summary>
    <author>
      <name>Ulrich Berger</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Swansea University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-7(1:8)2011</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-7(1:8)2011" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 7, Issue 1 (March 24,
  2011) lmcs:1109</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1101.2162v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.2162v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03F60" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.4465v1</id>
    <updated>2011-01-24T08:48:43Z</updated>
    <published>2011-01-24T08:48:43Z</published>
    <title>Extensional Collapse Situations I: non-termination and unrecoverable
  errors</title>
    <summary>  We consider a simple model of higher order, functional computation over the
booleans. Then, we enrich the model in order to encompass non-termination and
unrecoverable errors, taken separately or jointly. We show that the models so
defined form a lattice when ordered by the extensional collapse situation
relation, introduced in order to compare models with respect to the amount of
"intensional information" that they provide on computation. The proofs are
carried out by exhibiting suitable applied {lambda}-calculi, and by exploiting
the fundamental lemma of logical relations.
</summary>
    <author>
      <name>Antonio Bucciarelli</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1101.4465v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.4465v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1105.2725v1</id>
    <updated>2011-05-13T13:38:08Z</updated>
    <published>2011-05-13T13:38:08Z</published>
    <title>A Foundational View on Integration Problems</title>
    <summary>  The integration of reasoning and computation services across system and
language boundaries is a challenging problem of computer science. In this
paper, we use integration for the scenario where we have two systems that we
integrate by moving problems and solutions between them. While this scenario is
often approached from an engineering perspective, we take a foundational view.
Based on the generic declarative language MMT, we develop a theoretical
framework for system integration using theories and partial theory morphisms.
Because MMT permits representations of the meta-logical foundations themselves,
this includes integration across logics. We discuss safe and unsafe integration
schemes and devise a general form of safe integration.
</summary>
    <author>
      <name>Florian Rabe</name>
    </author>
    <author>
      <name>Michael Kohlhase</name>
    </author>
    <author>
      <name>Claudio Sacerdoti Coen</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-642-22673-1_8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-642-22673-1_8" rel="related"/>
    <link href="http://arxiv.org/abs/1105.2725v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1105.2725v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1107.2284v1</id>
    <updated>2011-07-12T13:34:50Z</updated>
    <published>2011-07-12T13:34:50Z</published>
    <title>The parallel versus branching recurrences in computability logic</title>
    <summary>  This paper shows that the basic logic induced by the parallel recurrence of
Computability Logic is a proper superset of the basic logic induced by the
branching recurrence. The latter is known to be precisely captured by the
cirquent calculus system CL15, conjectured by Japaridze to remain sound---but
not complete---with parallel recurrence instead of branching recurrence. The
present result is obtained by positively verifying that conjecture. A secondary
result of the paper is showing that parallel recurrence is strictly weaker than
branching recurrence in the sense that, while the latter logically implies the
former, vice versa does not hold.
</summary>
    <author>
      <name>Wenyan Xu</name>
    </author>
    <author>
      <name>Sanyang Liu</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1215/00294527-1731389</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1215/00294527-1731389" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Notre Dame J. Formal Logic 54, no. 1 (2013), 61-78</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1107.2284v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1107.2284v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1107.3706v1</id>
    <updated>2011-07-19T13:01:16Z</updated>
    <published>2011-07-19T13:01:16Z</published>
    <title>The countable versus uncountable branching recurrences in computability
  logic</title>
    <summary>  This paper introduces a new simplified version of the countable branching
recurrence of Computability Logic, proves its equivalence to the old one, and
shows that the basic logic induced by it is a proper superset of the basic
logic induced by the uncountable branching recurrence. A further result of this
paper is showing that the countable branching recurrence is strictly weaker
than the uncountable branching recurrence in the sense that the latter
logically implies the former but not vice versa.
</summary>
    <author>
      <name>Wenyan Xu</name>
    </author>
    <author>
      <name>Sanyang Liu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">20 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1107.3706v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1107.3706v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.3053v1</id>
    <updated>2011-12-13T21:47:07Z</updated>
    <published>2011-12-13T21:47:07Z</published>
    <title>Estimation of the length of interactions in arena game semantics</title>
    <summary>  We estimate the maximal length of interactions between strategies in HO/N
game semantics, in the spirit of the work by Schwichtenberg and Beckmann for
the length of reduction in simply typed lambdacalculus. Because of the
operational content of game semantics, the bounds presented here also apply to
head linear reduction on lambda-terms and to the execution of programs by
abstract machines (PAM/KAM), including in presence of computational effects
such as non-determinism or ground type references. The proof proceeds by
extracting from the games model a combinatorial rewriting rule on trees of
natural numbers, which can then be analyzed independently of game semantics or
lambda-calculus.
</summary>
    <author>
      <name>Pierre Clairambault</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-642-19805-2_23</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-642-19805-2_23" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Foundations of Software Science and Computational Structures 14th
  International Conference, FOSSACS 2011, Saarbr\\"ucken : Germany (2011)</arxiv:comment>
    <link href="http://arxiv.org/abs/1112.3053v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.3053v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.2744v1</id>
    <updated>2013-05-13T11:31:08Z</updated>
    <published>2013-05-13T11:31:08Z</published>
    <title>Time Estimation Model of Concurrent Computing Systems</title>
    <summary>  We consider an asynchronous system with transitions corresponding to the
instructions of a computer system. For each instruction, a runtime is given. We
propose a mathematical model, allowing us to construct an algorithm for finding
the minimum time of the parallel process with a given trace. We consider a
problem of constructing a parallel process which transforms the initial state
to given and has the minimum execution time. We show that it is reduced to the
problem of finding the shortest path in a directed graph with edge lengths
equal to 1.
</summary>
    <author>
      <name>Ahmet A. Husainov</name>
    </author>
    <author>
      <name>E. S. Kudryashova</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1305.2744v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.2744v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68Q10, 68Q85" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.7505v2</id>
    <updated>2015-07-12T10:10:21Z</updated>
    <published>2013-07-29T08:59:33Z</published>
    <title>Interactive Logic Programming via Choice-Disjunctive Clauses</title>
    <summary>  Adding interaction to logic programming is an essential task. Expressive
logics such as linear logic provide a theoretical basis for such a mechanism.
Unfortunately, none of the existing linear logic languages can model
interactions with the user. This is because they uses provability as the sole
basis for computation. We propose to use the game semantics instead of
provability as the basis for computation to allow for more active participation
from the user. We illustrate our idea via muprolog, an extension of Prolog with
choice-disjunctive clauses.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages. A new execution model is added to the previous version.
  arXiv admin note: substantial text overlap with arXiv:1211.6535</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.7505v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.7505v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1401.3280v2</id>
    <updated>2014-01-16T11:55:56Z</updated>
    <published>2014-01-14T18:48:25Z</published>
    <title>Groupoid Semantics for Thermal Computing</title>
    <summary>  A groupoid semantics is presented for systems with both logical and thermal
degrees of freedom. We apply this to a syntactic model for encryption, and
obtain an algebraic characterization of the heat produced by the encryption
function, as predicted by Landauer's principle. Our model has a linear
representation theory that reveals an underlying quantum semantics, giving for
the first time a functorial classical model for quantum teleportation and other
quantum phenomena.
</summary>
    <author>
      <name>Krzysztof Bar</name>
    </author>
    <author>
      <name>Jamie Vicary</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">We describe a groupoid model for thermodynamic computation, and a
  quantization procedure that turns encrypted communication into quantum
  teleportation. Everything is done using higher category theory</arxiv:comment>
    <link href="http://arxiv.org/abs/1401.3280v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1401.3280v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1503.09060v1</id>
    <updated>2015-03-28T00:38:33Z</updated>
    <published>2015-03-28T00:38:33Z</published>
    <title>A Tutorial Introduction to the Lambda Calculus</title>
    <summary>  This paper is a concise and painless introduction to the $lambda$-calculus.
This formalism was developed by Alonzo Church as a tool for studying the
mathematical properties of effectively computable functions. The formalism
became popular and has provided a strong theoretical foundation for the family
of functional programming languages. This tutorial shows how to perform
arithmetical and logical computations using the $lambda$-calculus and how to
define recursive functions, even though $lambda$-calculus functions are
unnamed and thus cannot refer explicitly to themselves.
</summary>
    <author>
      <name>Raul Rojas</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1503.09060v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1503.09060v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1210.5946v1</id>
    <updated>2012-10-22T16:11:55Z</updated>
    <published>2012-10-22T16:11:55Z</published>
    <title>Bipolar Proof Nets for MALL</title>
    <summary>  In this work we present a computation paradigm based on a concurrent and
incremental construction of proof nets (de-sequentialized or graphical proofs)
of the pure multiplicative and additive fragment of Linear Logic, a resources
conscious refinement of Classical Logic. Moreover, we set a correspon- dence
between this paradigm and those more pragmatic ones inspired to transactional
or distributed systems. In particular we show that the construction of additive
proof nets can be interpreted as a model for super-ACID (or co-operative)
transactions over distributed transactional systems (typi- cally,
multi-databases).
</summary>
    <author>
      <name>Roberto Maieli</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the "Proof, Computation, Complexity" International
  Workshop, 17-18 August 2012, University of Copenhagen, Denmark</arxiv:comment>
    <link href="http://arxiv.org/abs/1210.5946v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1210.5946v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.0835v1</id>
    <updated>2014-05-05T09:36:22Z</updated>
    <published>2014-05-05T09:36:22Z</published>
    <title>CEGAR for Qualitative Analysis of Probabilistic Systems</title>
    <summary>  We consider Markov decision processes (MDPs) which are a standard model for
probabilistic systems. We focus on qualitative properties for MDPs that can
express that desired behaviors of the system arise almost-surely (with
probability 1) or with positive probability. We introduce a new simulation
relation to capture the refinement relation of MDPs with respect to qualitative
properties, and present discrete graph theoretic algorithms with quadratic
complexity to compute the simulation relation. We present an automated
technique for assume-guarantee style reasoning for compositional analysis of
MDPs with qualitative properties by giving a counter-example guided
abstraction-refinement approach to compute our new simulation relation. We have
implemented our algorithms and show that the compositional analysis leads to
significant improvements.
</summary>
    <author>
      <name>Krishnendu Chatterjee</name>
    </author>
    <author>
      <name>Martin Chmelik</name>
    </author>
    <author>
      <name>Przemyslaw Daca</name>
    </author>
    <link href="http://arxiv.org/abs/1405.0835v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.0835v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1510.08331v2</id>
    <updated>2015-12-20T17:58:58Z</updated>
    <published>2015-10-28T14:54:34Z</published>
    <title>Structurally Cyclic Petri Nets</title>
    <summary>  A Petri net is structurally cyclic if every configuration is reachable from
itself in one or more steps. We show that structural cyclicity is decidable in
deterministic polynomial time. For this, we adapt the Kosaraju's approach for
the general reachability problem for Petri nets.
</summary>
    <author>
      <name>Drewes Frank</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dept. of Computing Science, Umeå University, Umeå, Sweden</arxiv:affiliation>
    </author>
    <author>
      <name>Leroux Jérôme</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LaBRI, CNRS</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-11(4:15)2015</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-11(4:15)2015" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages. Key words: Petri net, vector addition system, structural
  cyclicity, reachability</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 11, Issue 4 (December
  22, 2015) lmcs:1616</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1510.08331v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1510.08331v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1104.0617v1</id>
    <updated>2011-04-04T16:35:01Z</updated>
    <published>2011-04-04T16:35:01Z</published>
    <title>Computing Optimal Coverability Costs in Priced Timed Petri Nets</title>
    <summary>  We consider timed Petri nets, i.e., unbounded Petri nets where each token
carries a real-valued clock. Transition arcs are labeled with time intervals,
which specify constraints on the ages of tokens. Our cost model assigns token
storage costs per time unit to places, and firing costs to transitions. We
study the cost to reach a given control-state. In general, a cost-optimal run
may not exist. However, we show that the infimum of the costs is computable.
</summary>
    <author>
      <name>Parosh Aziz Abdulla</name>
    </author>
    <author>
      <name>Richard Mayr</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">26 pages. Contribution to LICS 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1104.0617v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1104.0617v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1403.4202v2</id>
    <updated>2014-04-17T22:13:42Z</updated>
    <published>2014-03-17T18:34:55Z</published>
    <title>Semantic information and artificial intelligence</title>
    <summary>  For a computational system to be intelligent, it should be able to perform,
at least, basic deductions. Nonetheless, since deductions are, in some sense,
equivalent to tautologies, it seems that they do not provide new information.
The present article proposes a measure the degree of semantic informativity of
valid deductions in a dynamic setting. Concepts of coherency and relevancy,
displayed in terms of insertions and deletions on databases, are used to define
semantic informativity. In this way, the article shows that a solution to the
problem about the informativity of deductions provides a heuristic principle to
improve the deductive power of computational systems.
</summary>
    <author>
      <name>Anderson de Araújo</name>
    </author>
    <link href="http://arxiv.org/abs/1403.4202v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1403.4202v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1404.1947v1</id>
    <updated>2014-04-07T20:50:53Z</updated>
    <published>2014-04-07T20:50:53Z</published>
    <title>Eine entscheidbare Klasse n-stelliger Horn-Prädikate</title>
    <summary>  Similar to a tree grammar, a Horn theory can be used to describe an infinite
set of terms. In this paper, we present a class of Horn theories such that the
set of definable predicates is closed wrt. conjunction and such that the
satisfiability of a predicate is decidable. This extends previous results on
Horn clauses with unary predicates.
</summary>
    <author>
      <name>Jochen Burghardt</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">in german; 11 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Peter H. Schmitt (ed.), Proc. 3rd Ann. Meeting of the German
  Computer Science Society (GI) Special Interest Group on Logic in Computer
  Science (FG 0.1.6), Karlsruhe University Internal Report 23/95, p.38-47, Jun
  1995</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1404.1947v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1404.1947v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68Q42" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.2; I.2.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.2110v1</id>
    <updated>2014-06-09T08:58:59Z</updated>
    <published>2014-06-09T08:58:59Z</published>
    <title>Logic Programming and Logarithmic Space</title>
    <summary>  We present an algebraic view on logic programming, related to proof theory
and more specifically linear logic and geometry of interaction. Within this
construction, a characterization of logspace (deterministic and
non-deterministic) computation is given via a synctactic restriction, using an
encoding of words that derives from proof theory.
  We show that the acceptance of a word by an observation (the counterpart of a
program in the encoding) can be decided within logarithmic space, by reducing
this problem to the acyclicity of a graph. We show moreover that observations
are as expressive as two-ways multi-heads finite automata, a kind of pointer
machines that is a standard model of logarithmic space computation.
</summary>
    <author>
      <name>Clément Aubert</name>
    </author>
    <author>
      <name>Marc Bagnol</name>
    </author>
    <author>
      <name>Paolo Pistone</name>
    </author>
    <author>
      <name>Thomas Seiller</name>
    </author>
    <link href="http://arxiv.org/abs/1406.2110v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.2110v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.5495v1</id>
    <updated>2014-06-20T19:42:17Z</updated>
    <published>2014-06-20T19:42:17Z</published>
    <title>Knowledge Representation in Agent's Logic with Uncertainty and Agent's
  Interaction</title>
    <summary>  This paper studies knowledge representation in multi-agent environment. We
investigate technique for computation truth-values of statements based at a new
temporal, agent's-knowledge logic TL. A logical language, mathematical symbolic
models and a temporal logic TL based at these models are suggested. We find an
algorithm which computes theorems of TL and satisfiability of statements, this
implies that TL is decidable (i.e. -- the satisfiability problem for TL is
solvable). Application areas are pointed and discussed.
</summary>
    <author>
      <name>Maybin Muyeba</name>
    </author>
    <author>
      <name>Vladimir Rybakov</name>
    </author>
    <link href="http://arxiv.org/abs/1406.5495v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.5495v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03B70" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.08280v1</id>
    <updated>2016-06-27T13:56:56Z</updated>
    <published>2016-06-27T13:56:56Z</published>
    <title>Inferring Covariances for Probabilistic Programs</title>
    <summary>  We study weakest precondition reasoning about the (co)variance of outcomes
and the variance of run-times of probabilistic programs with conditioning. For
outcomes, we show that approximating (co)variances is computationally more
difficult than approximating expected values. In particular, we prove that
computing both lower and upper bounds for (co)variances is
$Sigma^{0}_{2}$-complete. As a consequence, neither lower nor upper bounds are
computably enumerable. We therefore present invariant-based techniques that do
enable enumeration of both upper and lower bounds, once appropriate invariants
are found. Finally, we extend this approach to reasoning about run-time
variances.
</summary>
    <author>
      <name>Benjamin Lucien Kaminski</name>
    </author>
    <author>
      <name>Joost-Pieter Katoen</name>
    </author>
    <author>
      <name>Christoph Matheja</name>
    </author>
    <link href="http://arxiv.org/abs/1606.08280v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.08280v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.03129v1</id>
    <updated>2016-08-10T11:11:06Z</updated>
    <published>2016-08-10T11:11:06Z</published>
    <title>Reversible Multiparty Sessions with Checkpoints</title>
    <summary>  Reversible interactions model different scenarios, like biochemical systems
and human as well as automatic negotiations. We abstract interactions via
multiparty sessions enriched with named checkpoints. Computations can either go
forward or roll back to some checkpoints, where possibly different choices may
be taken. In this way communications can be undone and different conversations
may be tried. Interactions are typed with global types, which control also
rollbacks. Typeability of session participants in agreement with global types
ensures session fidelity and progress of reversible communications.
</summary>
    <author>
      <name>Mariangiola Dezani-Ciancaglini</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Universita' di Torino</arxiv:affiliation>
    </author>
    <author>
      <name>Paola Giannini</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Computer Science Institute, DiSIT, Universita' del Piemente Orientale</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.222.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.222.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings EXPRESS/SOS 2016, arXiv:1608.02692</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 222, 2016, pp. 60-74</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1608.03129v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.03129v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D3.3;F3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.07880v1</id>
    <updated>2016-08-29T01:35:55Z</updated>
    <published>2016-08-29T01:35:55Z</published>
    <title>(De-)Composing Causality in Labeled Transition Systems</title>
    <summary>  In this paper we introduce a notion of counterfactual causality in the
Halpern and Pearl sense that is compositional with respect to the interleaving
of transition systems. The formal framework for reasoning on what caused the
violation of a safety property is established in the context of labeled
transition systems and Hennessy Milner logic. The compositionality results are
devised for non-communicating systems.
</summary>
    <author>
      <name>Georgiana Caltais</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department for Computer and Information Science, University of Konstanz, Germany</arxiv:affiliation>
    </author>
    <author>
      <name>Stefan Leue</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department for Computer and Information Science, University of Konstanz, Germany</arxiv:affiliation>
    </author>
    <author>
      <name>Mohammad Reza Mousavi</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Centre for Research on Embedded Systems, Halmstad University, Sweden</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.224.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.224.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings CREST 2016, arXiv:1608.07398</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 224, 2016, pp. 10-24</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1608.07880v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.07880v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1110.6738v2</id>
    <updated>2011-11-16T08:31:00Z</updated>
    <published>2011-10-31T10:16:24Z</published>
    <title>An Incremental Knowledge Compilation in First Order Logic</title>
    <summary>  An algorithm to compute the set of prime implicates of a quantifier-free
clausal formula X in first order logic had been presented in earlier work. As
the knowledge base X is dynamic, new clauses are added to the old knowledge
base. In this paper an incremental algorithm is presented to compute the prime
implicates of X and a clause C from $pi(X)cup C$. The correctness of the
algorithm is also proved.
</summary>
    <author>
      <name>Manoj K. Raut</name>
    </author>
    <link href="http://arxiv.org/abs/1110.6738v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1110.6738v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.7488v2</id>
    <updated>2014-11-11T20:31:09Z</updated>
    <published>2014-09-26T07:51:37Z</published>
    <title>On the strictness of the quantifier structure hierarchy in first-order
  logic</title>
    <summary>  We study a natural hierarchy in first-order logic, namely the quantifier
structure hierarchy, which gives a systematic classification of first-order
formulas based on structural quantifier resource. We define a variant of
Ehrenfeucht-Fraisse games that characterizes quantifier classes and use it to
prove that this hierarchy is strict over finite structures, using strategy
compositions. Moreover, we prove that this hierarchy is strict even over
ordered finite structures, which is interesting in the context of descriptive
complexity.
</summary>
    <author>
      <name>Yuguo He</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">School of Computer Science and Technology, Beijing Institute of Technology, China</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-10(4:3)2014</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-10(4:3)2014" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">38 pages, 8 figures</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 10, Issue 4 (November
  13, 2014) lmcs:965</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1409.7488v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.7488v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.01123v1</id>
    <updated>2015-11-03T21:28:30Z</updated>
    <published>2015-11-03T21:28:30Z</published>
    <title>Adapting Real Quantifier Elimination Methods for Conflict Set
  Computation</title>
    <summary>  The satisfiability problem in real closed fields is decidable. In the context
of satisfiability modulo theories, the problem restricted to conjunctive sets
of literals, that is, sets of polynomial constraints, is of particular
importance. One of the central problems is the computation of good explanations
of the unsatisfiability of such sets, i.e.\\ obtaining a small subset of the
input constraints whose conjunction is already unsatisfiable. We adapt two
commonly used real quantifier elimination methods, cylindrical algebraic
decomposition and virtual substitution, to provide such conflict sets and
demonstrate the performance of our method in practice.
</summary>
    <author>
      <name>Maximilian Jaroschek</name>
    </author>
    <author>
      <name>Pablo Federico Dobal</name>
    </author>
    <author>
      <name>Pascal Fontaine</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Frontiers of Combining Systems, 151--166, isbn 978-3-319-24245-3,
  2015</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1511.01123v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.01123v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1609.02753v2</id>
    <updated>2017-03-22T13:55:11Z</updated>
    <published>2016-09-09T11:58:43Z</published>
    <title>Typing weak MSOL properties</title>
    <summary>  We consider lambda-Y-calculus as a non-interpreted functional programming
language: the result of the execution of a program is its normal form that can
be seen as the tree of calls to built-in operations. Weak monadic second-order
logic (wMSOL) is well suited to express properties of such trees. We give a
type system for ensuring that the result of the execution of a lambda-Y-program
satisfies a given wMSOL property. In order to prove soundness and completeness
of the system we construct a denotational semantics of lambda-Y-calculus that
is capable of computing properties expressed in wMSOL.
</summary>
    <author>
      <name>Sylvain Salvati</name>
    </author>
    <author>
      <name>Igor Walukiewicz</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.23638/LMCS-13(1:14)2017</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.23638/LMCS-13(1:14)2017" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 13, Issue 1 (March 23,
  2017) lmcs:3215</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1609.02753v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1609.02753v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1705.04744v1</id>
    <updated>2017-05-12T20:16:38Z</updated>
    <published>2017-05-12T20:16:38Z</published>
    <title>Intensionality, Definability and Computation</title>
    <summary>  We look at intensionality from the perspective of computation. In particular,
we review how game semantics has been used to characterize the sequential
functional processes, leading to powerful and flexible methods for constructing
fully abstract models of programming languages, with applications in program
analysis and verification. In a broader context, we can regard game semantics
as a first step towards developing a positive theory of intensional structures
with a robust mathematical structure, and finding the right notions of
invariance for these structures.
</summary>
    <author>
      <name>Samson Abramsky</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-319-06025-5_5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-319-06025-5_5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">23 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">In Johan van Benthem on Logic and Information Dynamics, A. Baltag
  and S. Smets, eds. Springer International Publishing, 2014. 121-142</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1705.04744v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1705.04744v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1706.07997v2</id>
    <updated>2017-12-06T14:29:49Z</updated>
    <published>2017-06-24T20:37:29Z</published>
    <title>In Search of Effectful Dependent Types</title>
    <summary>  Real world programming languages crucially depend on the availability of
computational effects to achieve programming convenience and expressive power
as well as program efficiency. Logical frameworks rely on predicates, or
dependent types, to express detailed logical properties about entities.
According to the Curry-Howard correspondence, programming languages and logical
frameworks should be very closely related. However, a language that has both
good support for real programming and serious proving is still missing from the
programming languages zoo. We believe this is due to a fundamental lack of
understanding of how dependent types should interact with computational
effects. In this thesis, we make a contribution towards such an understanding,
with a focus on semantic methods.
</summary>
    <author>
      <name>Matthijs Vákár</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">PhD thesis, Version submitted to Exam Schools</arxiv:comment>
    <link href="http://arxiv.org/abs/1706.07997v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1706.07997v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1707.08925v1</id>
    <updated>2017-07-27T16:26:04Z</updated>
    <published>2017-07-27T16:26:04Z</published>
    <title>Inductive and Functional Types in Ludics</title>
    <summary>  Ludics is a logical framework in which types/formulas are modelled by sets of
terms with the same computational behaviour. This paper investigates the
representation of inductive data types and functional types in ludics. We study
their structure following a game semantics approach. Inductive types are
interpreted as least fixed points, and we prove an internal completeness result
giving an explicit construction for such fixed points. The interactive
properties of the ludics interpretation of inductive and functional types are
then studied. In particular, we identify which higher-order functions types
fail to satisfy type safety, and we give a computational explanation.
</summary>
    <author>
      <name>Alice Pavaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Université Paris 13</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended version of the paper accepted for publication in CSL 2017,
  46 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1707.08925v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1707.08925v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1712.00570v1</id>
    <updated>2017-12-02T08:32:26Z</updated>
    <published>2017-12-02T08:32:26Z</published>
    <title>HySIA: Tool for Simulating and Monitoring Hybrid Automata Based on
  Interval Analysis</title>
    <summary>  We present HySIA: a reliable runtime verification tool for nonlinear hybrid
automata (HA) and signal temporal logic (STL) properties. HySIA simulates an HA
with interval analysis techniques so that a trajectory is enclosed sharply
within a set of intervals. Then, HySIA computes whether the simulated
trajectory satisfies a given STL property; the computation is performed again
with interval analysis to achieve reliability. Simulation and verification
using HySIA are demonstrated through several example HA and STL formulas.
</summary>
    <author>
      <name>Daisuke Ishii</name>
    </author>
    <author>
      <name>Alexandre Goldsztejn</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-319-67531-2_23</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-319-67531-2_23" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in RV'17; the final publication is available at Springer</arxiv:comment>
    <link href="http://arxiv.org/abs/1712.00570v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1712.00570v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1712.01800v1</id>
    <updated>2017-12-05T18:26:34Z</updated>
    <published>2017-12-05T18:26:34Z</published>
    <title>Computational Higher Type Theory III: Univalent Universes and Exact
  Equality</title>
    <summary>  This is the third in a series of papers extending Martin-L\\"of's meaning
explanations of dependent type theory to a Cartesian cubical realizability
framework that accounts for higher-dimensional types. We extend this framework
to include a cumulative hierarchy of univalent Kan universes of Kan types,
exact equality and other pretypes lacking Kan structure, and a cumulative
hierarchy of pretype universes. As in Parts I and II, the main result is a
canonicity theorem stating that closed terms of boolean type evaluate to either
true or false. This establishes the computational interpretation of Cartesian
cubical higher type theory based on cubical programs equipped with a
deterministic operational semantics.
</summary>
    <author>
      <name>Carlo Angiuli</name>
    </author>
    <author>
      <name>Kuen-Bang Hou</name>
    </author>
    <author>
      <name>Robert Harper</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">71 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1712.01800v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1712.01800v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1801.07438v1</id>
    <updated>2018-01-23T08:44:54Z</updated>
    <published>2018-01-23T08:44:54Z</published>
    <title>Higher-Order Equational Pattern Anti-Unification [Preprint]</title>
    <summary>  We consider anti-unification for simply typed lambda terms in associative,
commutative, and associative-commutative theories and develop a sound and
complete algorithm which takes two lambda terms and computes their
generalizations in the form of higher-order patterns. The problem is finitary:
the minimal complete set of generalizations contains finitely many elements. We
define the notion of optimal solution and investigate special fragments of the
problem for which the optimal solution can be computed in linear or polynomial
time.
</summary>
    <author>
      <name>David M. Cerna</name>
    </author>
    <author>
      <name>Temur Kutsia</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4230/LIPIcs.FSCD.2018.12</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4230/LIPIcs.FSCD.2018.12" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted to FSCD 2018</arxiv:comment>
    <link href="http://arxiv.org/abs/1801.07438v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1801.07438v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1805.10073v4</id>
    <updated>2019-02-15T12:37:12Z</updated>
    <published>2018-05-25T10:36:47Z</published>
    <title>Checking Deadlock-Freedom of Parametric Component-Based Systems</title>
    <summary>  We propose an automated method for computing inductive invariants applied to
check deadlock-freedom for parametric component-based systems. The method
generalizes the approach for computing structural trap invariants from bounded
to parametric systems with general architectures. It symbolically extracts trap
invariants from a monadic interaction formula characterizing the system
architecture. The paper presents the theoretical foundations of the method
including new results for the first order monadic logic and proves its
soundness. It also provides preliminary illustrations on examples.
</summary>
    <author>
      <name>Marius Bozga</name>
    </author>
    <author>
      <name>Radu Iosif</name>
    </author>
    <author>
      <name>Joseph Sifakis</name>
    </author>
    <link href="http://arxiv.org/abs/1805.10073v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1805.10073v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1806.00256v2</id>
    <updated>2018-10-25T12:16:53Z</updated>
    <published>2018-06-01T09:39:46Z</published>
    <title>The Complexity of Bisimulation and Simulation on Finite Systems</title>
    <summary>  In this paper the computational complexity of the (bi)simulation problem over
restricted graph classes is studied. For trees given as pointer structures or
terms the (bi)simulation problem is complete for logarithmic space or NC$^1$,
respectively. This solves an open problem from Balc'azar, Gabarr'o, and
S'antha. Furthermore, if only one of the input graphs is required to be a
tree, the bisimulation (simulation) problem is contained in AC$^1$ (LogCFL). In
contrast, it is also shown that the simulation problem is P-complete already
for graphs of bounded path-width.
</summary>
    <author>
      <name>Moses Ganardi</name>
    </author>
    <author>
      <name>Stefan Göller</name>
    </author>
    <author>
      <name>Markus Lohrey</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.23638/LMCS-14(4:5)2018</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.23638/LMCS-14(4:5)2018" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 14, Issue 4 (October
  26, 2018) lmcs:4922</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1806.00256v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1806.00256v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1810.05392v1</id>
    <updated>2018-10-12T08:03:44Z</updated>
    <published>2018-10-12T08:03:44Z</published>
    <title>Proceedings Seventh International Workshop on Classical Logic and
  Computation</title>
    <summary>  This special issue cover the seventh and last conference of the CL&amp;C series,
started in 2006 in San Servolo. Topics are the computational content of logics
between intuitionistic logic and classical logic, through normalization, and a
new topic, cyclic proofs and the complexity of checking the correctness of a
cyclic proof. Accepted papers include an empirical comparison of time
consumption of different normalization algorithms, and new reductions sets for
several extensions of intuitionistic logic having the Herbrand disjunction
property. Another paper provides a reduction set for admissible rules for
intuitionistic logic. A paper describes a subset of cyclic proofs having a
polynomial-time algorithm checking correctness.
</summary>
    <author>
      <name>Stefano Berardi</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Torino</arxiv:affiliation>
    </author>
    <author>
      <name>Alexandre Miquel</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Universidad de la Republica</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.281</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.281" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 281, 2018</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1810.05392v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1810.05392v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1902.05465v2</id>
    <updated>2019-04-07T20:01:18Z</updated>
    <published>2019-02-14T16:00:23Z</published>
    <title>Change Actions: Models of Generalised Differentiation</title>
    <summary>  Cai et al. have recently proposed change structures as a semantic framework
for incremental computation. We generalise change structures to arbitrary
cartesian categories and propose the notion of change action model as a
categorical model for (higher-order) generalised differentiation. Change action
models naturally arise from many geometric and computational settings, such as
(generalised) cartesian differential categories, group models of discrete
calculus, and Kleene algebra of regular expressions. We show how to build
canonical change action models on arbitrary cartesian categories, reminiscent
of the F\'aa di Bruno construction.
</summary>
    <author>
      <name>Mario Alvarez-Picallo</name>
    </author>
    <author>
      <name>C. -H. Luke Ong</name>
    </author>
    <link href="http://arxiv.org/abs/1902.05465v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1902.05465v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1902.08414v1</id>
    <updated>2019-02-22T09:35:53Z</updated>
    <published>2019-02-22T09:35:53Z</published>
    <title>Fast Computations on Ordered Nominal Sets</title>
    <summary>  We show how to compute efficiently with nominal sets over the total order
symmetry, by developing a direct representation of such nominal sets and basic
constructions thereon. In contrast to previous approaches, we work directly at
the level of orbits, which allows for an accurate complexity analysis. The
approach is implemented as the library ONS (Ordered Nominal Sets).
  Our main motivation is nominal automata, which are models for recognising
languages over infinite alphabets. We evaluate ONS in two applications:
minimisation of automata and active automata learning. In both cases, ONS is
competitive compared to existing implementations and outperforms them for
certain classes of inputs.
</summary>
    <author>
      <name>David Venhoek</name>
    </author>
    <author>
      <name>Joshua Moerman</name>
    </author>
    <author>
      <name>Jurriaan Rot</name>
    </author>
    <link href="http://arxiv.org/abs/1902.08414v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1902.08414v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1903.09818v2</id>
    <updated>2019-06-15T15:42:25Z</updated>
    <published>2019-03-23T13:22:38Z</published>
    <title>Harnessing Higher-Order (Meta-)Logic to Represent and Reason with
  Complex Ethical Theories</title>
    <summary>  The computer-mechanization of an ambitious explicit ethical theory, Gewirth's
Principle of Generic Consistency, is used to showcase an approach for
representing and reasoning with ethical theories exhibiting complex logical
features like alethic and deontic modalities, indexicals, higher-order
quantification, among others. Harnessing the high expressive power of Church's
type theory as a meta-logic to semantically embed a combination of quantified
non-classical logics, our work pushes existing boundaries in knowledge
representation and reasoning. We demonstrate that intuitive encodings of
complex ethical theories and their automation on the computer are no longer
antipodes.
</summary>
    <author>
      <name>David Fuenmayor</name>
    </author>
    <author>
      <name>Christoph Benzmüller</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1903.09818v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1903.09818v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03B60, 03B15, 68T27, 68T30, 68T15" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.3; I.2.4; I.2.0; F.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.01407v1</id>
    <updated>2019-04-02T13:42:42Z</updated>
    <published>2019-04-02T13:42:42Z</published>
    <title>On Transitive modal many-valued logics</title>
    <summary>  This paper is focused on the study of modal logics defined from valued Kripke
frames, and particularly, on computability and expressibility questions of
modal logics of transitive Kripke frames evaluated over certain residuated
lattices. It is shown that a large family of those logics -- including the ones
arising from the standard MV and Product algebras -- yields an undecidable
consequence relation. Later on, the behaviour of transitive modal Lukasiewicz
logic is compared with that of its non transitive counterpart, exhibiting some
particulars concerning computability and equivalence with other logics. We
conclude the article by showing the undecidability of the validity and the
local SAT questions over transitive models when the Delta operation is added to
the logic.
</summary>
    <author>
      <name>Amanda Vidal</name>
    </author>
    <link href="http://arxiv.org/abs/1904.01407v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.01407v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
</feed>

